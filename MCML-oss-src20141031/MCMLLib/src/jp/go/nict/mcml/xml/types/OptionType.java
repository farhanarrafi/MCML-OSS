/**
 * OptionType.java
 *
 * This file was generated by XMLSPY 2004 Enterprise Edition.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the XMLSPY Documentation for further details.
 * http://www.altova.com/xmlspy
 */


package jp.go.nict.mcml.xml.types;

import jp.go.nict.mcml.xml.altova.types.*;

public class OptionType extends jp.go.nict.mcml.xml.altova.xml.Node {
	public OptionType() {
		super();
	}

	public OptionType(OptionType node) {
		super(node);
	}

	public OptionType(org.w3c.dom.Node node) {
		super(node);
	}

	public OptionType(org.w3c.dom.Document doc) {
		super(doc);
	}
	public void adjustPrefix() {
		int count;
		count = getDomChildCount(Attribute, null, "Key");
		for (int i = 0; i < count; i++) {
			org.w3c.dom.Node tmpNode = getDomChildAt(Attribute, null, "Key", i);
			internalAdjustPrefix(tmpNode, false);
		}
		count = getDomChildCount(Attribute, null, "Value");
		for (int i = 0; i < count; i++) {
			org.w3c.dom.Node tmpNode = getDomChildAt(Attribute, null, "Value", i);
			internalAdjustPrefix(tmpNode, false);
		}
	}

	public int getKeyMinCount() {
		return 1;
	}

	public int getKeyMaxCount() {
		return 1;
	}

	public int getKeyCount() {
		return getDomChildCount(Attribute, null, "Key");
	}

	public boolean hasKey() {
		return hasDomChild(Attribute, null, "Key");
	}

	public SchemaString getKeyAt(int index) throws Exception {
		return new SchemaString(getDomNodeValue(getDomChildAt(Attribute, null, "Key", index)));
	}

	public SchemaString getKey() throws Exception {
		return getKeyAt(0);
	}

	public void removeKeyAt(int index) {
		removeDomChildAt(Attribute, null, "Key", index);
	}

	public void removeKey() {
		while (hasKey())
			removeKeyAt(0);
	}

	public void addKey(SchemaString value) {
		appendDomChild(Attribute, null, "Key", value.toString());
	}

	public void addKey(String value) throws Exception {
		addKey(new SchemaString(value));
	}

	public void insertKeyAt(SchemaString value, int index) {
		insertDomChildAt(Attribute, null, "Key", index, value.toString());
	}

	public void insertKeyAt(String value, int index) throws Exception {
		insertKeyAt(new SchemaString(value), index);
	}

	public void replaceKeyAt(SchemaString value, int index) {
		replaceDomChildAt(Attribute, null, "Key", index, value.toString());
	}

	public void replaceKeyAt(String value, int index) throws Exception {
		replaceKeyAt(new SchemaString(value), index);
	}

	public int getValueMinCount() {
		return 1;
	}

	public int getValueMaxCount() {
		return 1;
	}

	public int getValueCount() {
		return getDomChildCount(Attribute, null, "Value");
	}

	public boolean hasValue() {
		return hasDomChild(Attribute, null, "Value");
	}

	public SchemaString getValueAt(int index) throws Exception {
		return new SchemaString(getDomNodeValue(getDomChildAt(Attribute, null, "Value", index)));
	}

	public SchemaString getValue() throws Exception {
		return getValueAt(0);
	}

	public void removeValueAt(int index) {
		removeDomChildAt(Attribute, null, "Value", index);
	}

	public void removeValue() {
		while (hasValue())
			removeValueAt(0);
	}

	public void addValue(SchemaString value) {
		appendDomChild(Attribute, null, "Value", value.toString());
	}

	public void addValue(String value) throws Exception {
		addValue(new SchemaString(value));
	}

	public void insertValueAt(SchemaString value, int index) {
		insertDomChildAt(Attribute, null, "Value", index, value.toString());
	}

	public void insertValueAt(String value, int index) throws Exception {
		insertValueAt(new SchemaString(value), index);
	}

	public void replaceValueAt(SchemaString value, int index) {
		replaceDomChildAt(Attribute, null, "Value", index, value.toString());
	}

	public void replaceValueAt(String value, int index) throws Exception {
		replaceValueAt(new SchemaString(value), index);
	}
}
