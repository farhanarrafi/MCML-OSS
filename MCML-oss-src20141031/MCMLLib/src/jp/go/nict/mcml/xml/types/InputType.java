/**
 * InputType.java
 *
 * This file was generated by XMLSPY 2004 Enterprise Edition.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the XMLSPY Documentation for further details.
 * http://www.altova.com/xmlspy
 */


package jp.go.nict.mcml.xml.types;

import jp.go.nict.mcml.xml.altova.types.*;

public class InputType extends jp.go.nict.mcml.xml.altova.xml.Node {
	public InputType() {
		super();
	}

	public InputType(InputType node) {
		super(node);
	}

	public InputType(org.w3c.dom.Node node) {
		super(node);
	}

	public InputType(org.w3c.dom.Document doc) {
		super(doc);
	}
	public void adjustPrefix() {
		int count;
		count = getDomChildCount(Element, null, "Data");
		for (int i = 0; i < count; i++) {
			org.w3c.dom.Node tmpNode = getDomChildAt(Element, null, "Data", i);
			internalAdjustPrefix(tmpNode, true);
			new DataType(tmpNode).adjustPrefix();
		}
		count = getDomChildCount(Element, null, "AttachedBinary");
		for (int i = 0; i < count; i++) {
			org.w3c.dom.Node tmpNode = getDomChildAt(Element, null, "AttachedBinary", i);
			internalAdjustPrefix(tmpNode, true);
			new AttachedBinaryType(tmpNode).adjustPrefix();
		}
	}

	public int getDataMinCount() {
		return 1;
	}

	public int getDataMaxCount() {
		return 1;
	}

	public int getDataCount() {
		return getDomChildCount(Element, null, "Data");
	}

	public boolean hasData() {
		return hasDomChild(Element, null, "Data");
	}

	public DataType getDataAt(int index) throws Exception {
		return new DataType(getDomChildAt(Element, null, "Data", index));
	}

	public DataType getData() throws Exception {
		return getDataAt(0);
	}

	public void removeDataAt(int index) {
		removeDomChildAt(Element, null, "Data", index);
	}

	public void removeData() {
		while (hasData())
			removeDataAt(0);
	}

	public void addData(DataType value) {
		appendDomElement(null, "Data", value);
	}

	public void insertDataAt(DataType value, int index) {
		insertDomElementAt(null, "Data", index, value);
	}

	public void replaceDataAt(DataType value, int index) {
		replaceDomElementAt(null, "Data", index, value);
	}

	public int getAttachedBinaryMinCount() {
		return 0;
	}

	public int getAttachedBinaryMaxCount() {
		return Integer.MAX_VALUE;
	}

	public int getAttachedBinaryCount() {
		return getDomChildCount(Element, null, "AttachedBinary");
	}

	public boolean hasAttachedBinary() {
		return hasDomChild(Element, null, "AttachedBinary");
	}

	public AttachedBinaryType getAttachedBinaryAt(int index) throws Exception {
		return new AttachedBinaryType(getDomChildAt(Element, null, "AttachedBinary", index));
	}

	public AttachedBinaryType getAttachedBinary() throws Exception {
		return getAttachedBinaryAt(0);
	}

	public void removeAttachedBinaryAt(int index) {
		removeDomChildAt(Element, null, "AttachedBinary", index);
	}

	public void removeAttachedBinary() {
		while (hasAttachedBinary())
			removeAttachedBinaryAt(0);
	}

	public void addAttachedBinary(AttachedBinaryType value) {
		appendDomElement(null, "AttachedBinary", value);
	}

	public void insertAttachedBinaryAt(AttachedBinaryType value, int index) {
		insertDomElementAt(null, "AttachedBinary", index, value);
	}

	public void replaceAttachedBinaryAt(AttachedBinaryType value, int index) {
		replaceDomElementAt(null, "AttachedBinary", index, value);
	}
}
