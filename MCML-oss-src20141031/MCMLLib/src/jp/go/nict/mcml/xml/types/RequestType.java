/**
 * RequestType.java
 *
 * This file was generated by XMLSPY 2004 Enterprise Edition.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the XMLSPY Documentation for further details.
 * http://www.altova.com/xmlspy
 */


package jp.go.nict.mcml.xml.types;

import jp.go.nict.mcml.xml.altova.types.*;

public class RequestType extends jp.go.nict.mcml.xml.altova.xml.Node {
	public RequestType() {
		super();
	}

	public RequestType(RequestType node) {
		super(node);
	}

	public RequestType(org.w3c.dom.Node node) {
		super(node);
	}

	public RequestType(org.w3c.dom.Document doc) {
		super(doc);
	}
	public void adjustPrefix() {
		int count;
		count = getDomChildCount(Attribute, null, "Service");
		for (int i = 0; i < count; i++) {
			org.w3c.dom.Node tmpNode = getDomChildAt(Attribute, null, "Service", i);
			internalAdjustPrefix(tmpNode, false);
		}
		count = getDomChildCount(Attribute, null, "ProcessOrder");
		for (int i = 0; i < count; i++) {
			org.w3c.dom.Node tmpNode = getDomChildAt(Attribute, null, "ProcessOrder", i);
			internalAdjustPrefix(tmpNode, false);
		}
		count = getDomChildCount(Element, null, "Routing");
		for (int i = 0; i < count; i++) {
			org.w3c.dom.Node tmpNode = getDomChildAt(Element, null, "Routing", i);
			internalAdjustPrefix(tmpNode, true);
			new RoutingType(tmpNode).adjustPrefix();
		}
		count = getDomChildCount(Element, null, "InputUserProfile");
		for (int i = 0; i < count; i++) {
			org.w3c.dom.Node tmpNode = getDomChildAt(Element, null, "InputUserProfile", i);
			internalAdjustPrefix(tmpNode, true);
			new InputUserProfileType(tmpNode).adjustPrefix();
		}
		count = getDomChildCount(Element, null, "TargetOutput");
		for (int i = 0; i < count; i++) {
			org.w3c.dom.Node tmpNode = getDomChildAt(Element, null, "TargetOutput", i);
			internalAdjustPrefix(tmpNode, true);
			new TargetOutputType(tmpNode).adjustPrefix();
		}
		count = getDomChildCount(Element, null, "Input");
		for (int i = 0; i < count; i++) {
			org.w3c.dom.Node tmpNode = getDomChildAt(Element, null, "Input", i);
			internalAdjustPrefix(tmpNode, true);
			new InputType(tmpNode).adjustPrefix();
		}
	}

	public int getServiceMinCount() {
		return 1;
	}

	public int getServiceMaxCount() {
		return 1;
	}

	public int getServiceCount() {
		return getDomChildCount(Attribute, null, "Service");
	}

	public boolean hasService() {
		return hasDomChild(Attribute, null, "Service");
	}

	public SchemaString getServiceAt(int index) throws Exception {
		return new SchemaString(getDomNodeValue(getDomChildAt(Attribute, null, "Service", index)));
	}

	public SchemaString getService() throws Exception {
		return getServiceAt(0);
	}

	public void removeServiceAt(int index) {
		removeDomChildAt(Attribute, null, "Service", index);
	}

	public void removeService() {
		while (hasService())
			removeServiceAt(0);
	}

	public void addService(SchemaString value) {
		appendDomChild(Attribute, null, "Service", value.toString());
	}

	public void addService(String value) throws Exception {
		addService(new SchemaString(value));
	}

	public void insertServiceAt(SchemaString value, int index) {
		insertDomChildAt(Attribute, null, "Service", index, value.toString());
	}

	public void insertServiceAt(String value, int index) throws Exception {
		insertServiceAt(new SchemaString(value), index);
	}

	public void replaceServiceAt(SchemaString value, int index) {
		replaceDomChildAt(Attribute, null, "Service", index, value.toString());
	}

	public void replaceServiceAt(String value, int index) throws Exception {
		replaceServiceAt(new SchemaString(value), index);
	}

	public int getProcessOrderMinCount() {
		return 1;
	}

	public int getProcessOrderMaxCount() {
		return 1;
	}

	public int getProcessOrderCount() {
		return getDomChildCount(Attribute, null, "ProcessOrder");
	}

	public boolean hasProcessOrder() {
		return hasDomChild(Attribute, null, "ProcessOrder");
	}

	public SchemaInt getProcessOrderAt(int index) throws Exception {
		return new SchemaInt(getDomNodeValue(getDomChildAt(Attribute, null, "ProcessOrder", index)));
	}

	public SchemaInt getProcessOrder() throws Exception {
		return getProcessOrderAt(0);
	}

	public void removeProcessOrderAt(int index) {
		removeDomChildAt(Attribute, null, "ProcessOrder", index);
	}

	public void removeProcessOrder() {
		while (hasProcessOrder())
			removeProcessOrderAt(0);
	}

	public void addProcessOrder(SchemaInt value) {
		appendDomChild(Attribute, null, "ProcessOrder", value.toString());
	}

	public void addProcessOrder(String value) throws Exception {
		addProcessOrder(new SchemaInt(value));
	}

	public void insertProcessOrderAt(SchemaInt value, int index) {
		insertDomChildAt(Attribute, null, "ProcessOrder", index, value.toString());
	}

	public void insertProcessOrderAt(String value, int index) throws Exception {
		insertProcessOrderAt(new SchemaInt(value), index);
	}

	public void replaceProcessOrderAt(SchemaInt value, int index) {
		replaceDomChildAt(Attribute, null, "ProcessOrder", index, value.toString());
	}

	public void replaceProcessOrderAt(String value, int index) throws Exception {
		replaceProcessOrderAt(new SchemaInt(value), index);
	}

	public int getRoutingMinCount() {
		return 1;
	}

	public int getRoutingMaxCount() {
		return 1;
	}

	public int getRoutingCount() {
		return getDomChildCount(Element, null, "Routing");
	}

	public boolean hasRouting() {
		return hasDomChild(Element, null, "Routing");
	}

	public RoutingType getRoutingAt(int index) throws Exception {
		return new RoutingType(getDomChildAt(Element, null, "Routing", index));
	}

	public RoutingType getRouting() throws Exception {
		return getRoutingAt(0);
	}

	public void removeRoutingAt(int index) {
		removeDomChildAt(Element, null, "Routing", index);
	}

	public void removeRouting() {
		while (hasRouting())
			removeRoutingAt(0);
	}

	public void addRouting(RoutingType value) {
		appendDomElement(null, "Routing", value);
	}

	public void insertRoutingAt(RoutingType value, int index) {
		insertDomElementAt(null, "Routing", index, value);
	}

	public void replaceRoutingAt(RoutingType value, int index) {
		replaceDomElementAt(null, "Routing", index, value);
	}

	public int getInputUserProfileMinCount() {
		return 0;
	}

	public int getInputUserProfileMaxCount() {
		return Integer.MAX_VALUE;
	}

	public int getInputUserProfileCount() {
		return getDomChildCount(Element, null, "InputUserProfile");
	}

	public boolean hasInputUserProfile() {
		return hasDomChild(Element, null, "InputUserProfile");
	}

	public InputUserProfileType getInputUserProfileAt(int index) throws Exception {
		return new InputUserProfileType(getDomChildAt(Element, null, "InputUserProfile", index));
	}

	public InputUserProfileType getInputUserProfile() throws Exception {
		return getInputUserProfileAt(0);
	}

	public void removeInputUserProfileAt(int index) {
		removeDomChildAt(Element, null, "InputUserProfile", index);
	}

	public void removeInputUserProfile() {
		while (hasInputUserProfile())
			removeInputUserProfileAt(0);
	}

	public void addInputUserProfile(InputUserProfileType value) {
		appendDomElement(null, "InputUserProfile", value);
	}

	public void insertInputUserProfileAt(InputUserProfileType value, int index) {
		insertDomElementAt(null, "InputUserProfile", index, value);
	}

	public void replaceInputUserProfileAt(InputUserProfileType value, int index) {
		replaceDomElementAt(null, "InputUserProfile", index, value);
	}

	public int getTargetOutputMinCount() {
		return 0;
	}

	public int getTargetOutputMaxCount() {
		return 1;
	}

	public int getTargetOutputCount() {
		return getDomChildCount(Element, null, "TargetOutput");
	}

	public boolean hasTargetOutput() {
		return hasDomChild(Element, null, "TargetOutput");
	}

	public TargetOutputType getTargetOutputAt(int index) throws Exception {
		return new TargetOutputType(getDomChildAt(Element, null, "TargetOutput", index));
	}

	public TargetOutputType getTargetOutput() throws Exception {
		return getTargetOutputAt(0);
	}

	public void removeTargetOutputAt(int index) {
		removeDomChildAt(Element, null, "TargetOutput", index);
	}

	public void removeTargetOutput() {
		while (hasTargetOutput())
			removeTargetOutputAt(0);
	}

	public void addTargetOutput(TargetOutputType value) {
		appendDomElement(null, "TargetOutput", value);
	}

	public void insertTargetOutputAt(TargetOutputType value, int index) {
		insertDomElementAt(null, "TargetOutput", index, value);
	}

	public void replaceTargetOutputAt(TargetOutputType value, int index) {
		replaceDomElementAt(null, "TargetOutput", index, value);
	}

	public int getInputMinCount() {
		return 0;
	}

	public int getInputMaxCount() {
		return 1;
	}

	public int getInputCount() {
		return getDomChildCount(Element, null, "Input");
	}

	public boolean hasInput() {
		return hasDomChild(Element, null, "Input");
	}

	public InputType getInputAt(int index) throws Exception {
		return new InputType(getDomChildAt(Element, null, "Input", index));
	}

	public InputType getInput() throws Exception {
		return getInputAt(0);
	}

	public void removeInputAt(int index) {
		removeDomChildAt(Element, null, "Input", index);
	}

	public void removeInput() {
		while (hasInput())
			removeInputAt(0);
	}

	public void addInput(InputType value) {
		appendDomElement(null, "Input", value);
	}

	public void insertInputAt(InputType value, int index) {
		insertDomElementAt(null, "Input", index, value);
	}

	public void replaceInputAt(InputType value, int index) {
		replaceDomElementAt(null, "Input", index, value);
	}
}
