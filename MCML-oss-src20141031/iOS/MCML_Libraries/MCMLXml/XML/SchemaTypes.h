////////////////////////////////////////////////////////////////////////
//
// SchemaTypes.h
//
// This file was generated by XMLSPY 2004 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSPY Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#ifndef MCML_SCHEMATYPES_H_INCLUDED
#define MCML_SCHEMATYPES_H_INCLUDED

#ifdef WIN32
#pragma warning(disable:4996)
#endif


#include <string>

#if defined(UNICODE) || defined(_UNICODE)
	#define tstring		std::wstring
	#define tcin		std::wcin
	#define tcout		std::wcout
	#define tcerr		std::wcerr
	#define tclog		std::wclog
	#define tostream	std::wostream
#else
	#define tstring		std::string
	#define tcin		std::cin
	#define tcout		std::cout
	#define tcerr		std::cerr
	#define tclog		std::clog
	#define tostream	std::ostream
#endif

#define	TCHAR	char
#define	_T(x)	x
#define	_ttoi		atoi
#define	_ttol		atol
#define	_ttoi64		atoll
#define	_tcstod		strtod
#define	_tcstol		strtol
#define	_tcscmp		strcmp
#define	_tcscat		strcat
#define	_tcslen		strlen
#define	_stprintf	sprintf
#define	_sntprintf	snprintf
#define	_I64_MAX	LLONG_MAX
#define	_I64_MIN	LLONG_MIN
#define	_I32_MAX	LONG_MAX
#define	_I32_MIN	LONG_MIN
#define	_UI32_MAX	ULONG_MAX
#define	_UI32_MIN	ULONG_MIN

inline unsigned char* toXmlChar(const char* const sz) { return (unsigned char*)sz; }
inline unsigned char* toXmlChar(const std::string& str) { return (unsigned char*)str.c_str(); }

#define	XC2TS(x)	((char *)x)
#define	X(str)		(toXmlChar(str))

#define	LLONG	long long

#include "XMLException.h"

namespace mcml{
////////////////////////////////////////////////////////////////////////
//
//  Utility functions and templates
//
////////////////////////////////////////////////////////////////////////

template<typename TValue>
TValue InRangeInt(TValue nValue, LLONG nMin, LLONG nMax)
{
	if( nValue < nMin || nValue > nMax )
		throw new CXMLException(CXMLException::eError1, _T("Out of range!"));
	return nValue;
}


template<typename TValue>
TValue InRangeDbl(TValue nValue, const double nPosMin, const double nPosMax)
{
	TValue nTmpValue = nValue;
	if( nTmpValue == 0 )
		return nValue;
	if( nTmpValue < 0 )
		nTmpValue = -nTmpValue;
	if( nTmpValue >= nPosMin  &&  nTmpValue <= nPosMax )
		return nValue;
	throw new CXMLException(CXMLException::eError1, _T("Out of range!"));
}

////////////////////////////////////////////////////////////////////////
//
//  CBaseObject
//
////////////////////////////////////////////////////////////////////////


class  CBaseObject
{
public:
	virtual ~CBaseObject() {}
};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaType
//
////////////////////////////////////////////////////////////////////////



class  CSchemaType : public CBaseObject
{
public:
	typedef enum {
		// numeric types
		k_bool,
		k_byte,
		k_unsigned_byte,
		k_short,
		k_unsigned_short,
		k_int,
		k_unsigned_int,
		k_long,
		k_unsigned_long,
		k_float,
		k_double,
		k_decimal,
		// calendar types
		k_Duration,
		k_Time,
		k_Day,
		k_Month,
		k_MonthDay,
		k_Year,
		k_YearMonth,
		k_Date,
		k_DateTime,
		// else
		k_String,
		k_Base64Binary,
		k_HexBinary,
		// ----------
		k_count,
		k_unknown = -1
	} ETypes ;

	CSchemaType(const bool isEmpty = true) : m_bIsEmpty( isEmpty ) {};
	virtual ~CSchemaType() {}

	enum { TYPE = k_unknown };

	virtual operator tstring() const = 0;

	virtual bool ToBool() const = 0;	// like XPATH function boolean()

	virtual void Empty()	{ m_bIsEmpty = true; }
	virtual void Parse(const TCHAR* szValue) = 0;
	virtual CSchemaType& Assign(const CSchemaType& rOther) = 0;

	bool	IsEmpty() const { return m_bIsEmpty; }

	enum {
		WHITESPACE_PRESERVE,
		WHITESPACE_REPLACE,
		WHITESPACE_COLLAPSE
	};

	static bool	CompareEqual(const CSchemaType& rObj1, const CSchemaType& rObj2);
	static bool	CompareLess(const CSchemaType& rObj1, const CSchemaType& rObj2);

	static bool CompareNotEqual(const CSchemaType& rObj1, const CSchemaType& rObj2)	{ return !CompareEqual(rObj1, rObj2); }
	static bool CompareGreater(const CSchemaType& rObj1, const CSchemaType& rObj2)	{ return CompareLess(rObj2, rObj1); }
	static bool CompareLessEqual(const CSchemaType& rObj1, const CSchemaType& rObj2)	{ return CompareLess(rObj1, rObj2) || CompareEqual(rObj1, rObj2); }
	static bool CompareGreaterEqual(const CSchemaType& rObj1, const CSchemaType& rObj2)	{ return CompareLess(rObj2, rObj1) || CompareEqual(rObj1, rObj2); }

protected:
	bool	m_bIsEmpty;
};


// --- deleted ---
//inline tostream& operator<<(tostream& os, CSchemaType& t)
//{
//	return os << ((tstring)t).c_str();
//}
// --- deleted ---


////////////////////////////////////////////////////////////////////////
//
//  CSchemaTypeNumber
//
////////////////////////////////////////////////////////////////////////

class  CSchemaTypeNumber
{
public:
	CSchemaTypeNumber() {};

	// architecture used is min. 32-bit so all smaller datatypes are omitted for calculation purposes
	// Note: unsigned datatypes have to be casted explicitly
	virtual long			ToLong() const = 0;		// 32 Bit integer
	virtual LLONG			ToInt64() const = 0;	// 64 Bit integer
	virtual float			ToFloat() const = 0;	// 32 Bit floating-point
	virtual double			ToDouble() const = 0;	// 64 Bit floating-point

	virtual CSchemaType::ETypes NumericType() const = 0;
	// --- modified ---
	// static TCHAR* GetFormatString(CSchemaType::ETypes eType)
	static const TCHAR* GetFormatString(CSchemaType::ETypes eType)
	// --- modified ---
	{
		switch( eType )
		{
		case CSchemaType::k_byte:			return	_T("%hi");
		case CSchemaType::k_unsigned_byte:	return	_T("%hu");
		case CSchemaType::k_short:			return	_T("%hi");
		case CSchemaType::k_unsigned_short:	return	_T("%hu");
		case CSchemaType::k_int:			return	_T("%li");
		case CSchemaType::k_unsigned_int:	return	_T("%lu");
		case CSchemaType::k_long:			return	_T("%I64i");
		case CSchemaType::k_unsigned_long:	return	_T("%I64u");
		case CSchemaType::k_float:			return	_T("%G");
		case CSchemaType::k_double:			return	_T("%lG");
		case CSchemaType::k_decimal:		return	_T("%lG");
		// --- added ---
		default: break ;
		// --- added ---
		}
		return _T("");
	}

};


//	calctype and ToCalcType() below are used for numerical operations with
//  CSchema... types (containing a value possible to be represented as number)
//  All numerical calculation functions access the value via ToCalcType().
//	Calculation-type is minimum 32 Bit (because we've 32 Bit processors) and
//	must be always signed (for unsigned use the next bigger type).

////////////////////////////////////////////////////////////////////////
//
//  template CSchemaNumber<..>
//
////////////////////////////////////////////////////////////////////////


template <typename TValue, typename TCalcValue, CSchemaType::ETypes eNumericType> 
class CSchemaNumber : public CSchemaTypeNumber, public CSchemaType
{
public:
	CSchemaNumber() : m_Value(0) {};
	CSchemaNumber(const TValue value) : CSchemaType( false ), m_Value(value) {};
	CSchemaNumber(const TCHAR* szValue) { Parse(szValue); }
	CSchemaNumber(const CSchemaType& rOther) { *this = rOther; }

	enum { TYPE = eNumericType };

	virtual operator TValue() const			{ return m_bIsEmpty ? (TValue)0	: m_Value; }
	/*virtual*/ CSchemaNumber& operator=(const TValue nValue)	{ m_bIsEmpty = false; m_Value = nValue; return *this; }
	/*virtual*/ CSchemaNumber& operator=(const CSchemaType& rOther)	{ return (CSchemaNumber&)Assign(rOther); }

	TCalcValue ToCalcValue() const { return (TCalcValue)m_Value; }

	// from CSchemaType
	virtual bool ToBool() const			{ return m_bIsEmpty ? (bool)0	: m_Value != 0; }
	virtual operator tstring() const		
	{ 
		if( m_bIsEmpty )
			return _T("");
		TCHAR szValue[32];
		_sntprintf(szValue, 32, GetFormatString(eNumericType), m_Value);
		return szValue;
	}

	void	Empty() { m_Value = 0; m_bIsEmpty = 1; }
	virtual void Parse(const TCHAR* szValue)
	{
		if( szValue[0] == 0 )
		{
			Empty();
			return;
		}
		m_bIsEmpty = false;
		InternalParse( szValue );
	}
	virtual CSchemaType& Assign(const CSchemaType& rOther )
	{
		Empty();
		const CSchemaTypeNumber* pNumberType = dynamic_cast<const CSchemaTypeNumber*>(&rOther);
		if( pNumberType == NULL )
			throw CXMLException(CXMLException::eError1, _T("Types incompatible!"));
		m_bIsEmpty = rOther.IsEmpty();
		switch( TYPE )
		{
		case CSchemaType::k_float:			m_Value = (TValue)pNumberType->ToFloat();	break;
		case CSchemaType::k_double:
		case CSchemaType::k_decimal:		m_Value = (TValue)pNumberType->ToDouble();	break;
		case CSchemaType::k_long:
		case CSchemaType::k_unsigned_long:	m_Value = (TValue)pNumberType->ToInt64();	break;
		default:
			m_Value = (TValue)pNumberType->ToLong();
		}
		return *this;
	}

	// from CSchemaTypeNumber
	virtual ETypes			NumericType() const	{ return (CSchemaType::ETypes)TYPE; }
	virtual long			ToLong() const		{ return m_bIsEmpty ? (long)0			: InRangeInt<long>((long)m_Value, LONG_MIN, LONG_MAX); }
	virtual LLONG	ToInt64() const		{ return m_bIsEmpty ? (LLONG)0	: InRangeInt<LLONG>((LLONG)m_Value, _I64_MIN, _I64_MAX); }
	virtual float			ToFloat() const		{ return m_bIsEmpty ? (float)0			: InRangeDbl<float>((float)m_Value, 3.4E-38, 3.4E+38); }
	virtual double			ToDouble() const	{ return m_bIsEmpty ? (double)0			: InRangeDbl<double>((double)m_Value, 1.7E-308, 1.7E+308); }

	typedef TValue basetype;
	typedef TCalcValue	calctype;
protected:
	TValue m_Value;

// --- modified ---
	virtual void InternalParse(const TCHAR* szValue);
//	void InternalParse(const TCHAR* szValue)
//	{
//		m_Value = _ttoi(szValue);
//	}
// --- modified ---
};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaByte
//	CSchemaUnsignedByte
//	CSchemaShort
//	CSchemaUnsignedShort
//	CSchemaInt
//	CSchemaUnsignedInt
//	CSchemaLong
//	CSchemaUnsignedLong
//	CSchemaFloat
//	CSchemaDouble
//	CSchemaDecimal
//
//	CSchemaInteger
//	CSchemaNegativeInteger
//	CSchemaPositiveInteger
//	CSchemaNonPositiveInteger
//
////////////////////////////////////////////////////////////////////////


typedef CSchemaNumber<char,						long,			CSchemaType::k_byte				>	CSchemaByte;
typedef CSchemaNumber<unsigned char,			long,			CSchemaType::k_unsigned_byte	>	CSchemaUnsignedByte;
typedef CSchemaNumber<short,					long,			CSchemaType::k_short			>	CSchemaShort;
typedef CSchemaNumber<unsigned short,			long,			CSchemaType::k_unsigned_short	>	CSchemaUnsignedShort;
typedef CSchemaNumber<long,						long,			CSchemaType::k_int				>	CSchemaInt;	
typedef CSchemaNumber<unsigned long,			LLONG,	CSchemaType::k_unsigned_int		>	CSchemaUnsignedInt;
typedef CSchemaNumber<LLONG,				LLONG,	CSchemaType::k_long				>	CSchemaLong;
typedef CSchemaNumber<unsigned LLONG,	LLONG,	CSchemaType::k_unsigned_long	>	CSchemaUnsignedLong;
typedef CSchemaNumber<float,					float,			CSchemaType::k_float			>	CSchemaFloat;
typedef CSchemaNumber<double,					double,			CSchemaType::k_double			>	CSchemaDouble;
typedef CSchemaNumber<double,					double,			CSchemaType::k_decimal			>	CSchemaDecimal;

typedef CSchemaLong		CSchemaInteger;
typedef CSchemaInteger	CSchemaNegativeInteger;
typedef CSchemaInteger	CSchemaNonNegativeInteger;
typedef CSchemaInteger	CSchemaPositiveInteger;
typedef CSchemaInteger	CSchemaNonPositiveInteger;


/*
template<> 
float CSchemaUnsignedLong::ToFloat() const
{
	return m_bIsEmpty ? (float)0.0	: InRangeDbl<float>((float)InRangeInt<LLONG>(m_Value, _I64_MIN, _I64_MAX), 3.4E-38, 3.4E+38); 
}

template<>
double CSchemaUnsignedLong::ToDouble() const
{
	return m_bIsEmpty ? (double)0.0	: InRangeDbl<double>((double)InRangeInt<LLONG>(m_Value, _I64_MIN, _I64_MAX), 1.7E-308, 1.7E+308); 	
}

template<>
void CSchemaInt::InternalParse(const TCHAR* szValue)
{
	m_Value = _ttol(szValue);
}

template<>
void CSchemaUnsignedInt::InternalParse(const TCHAR* szValue)
{
	m_Value = _ttol(szValue);
}

template<>
void CSchemaLong::InternalParse(const TCHAR* szValue)
{
	m_Value = _ttoi64(szValue);
}

template<>
void CSchemaUnsignedLong::InternalParse(const TCHAR* szValue)
{
	m_Value = _ttoi64(szValue);
}

template<>
void CSchemaFloat::InternalParse(const TCHAR* szValue)
{
	TCHAR* endptr;
	m_Value = (float)_tcstod(szValue, &endptr);
}

template<>
void CSchemaDouble::InternalParse(const TCHAR* szValue)
{
	TCHAR* endptr;
	m_Value = _tcstod(szValue, &endptr);
}

template<>
void CSchemaDecimal::InternalParse(const TCHAR* szValue)
{
	TCHAR* endptr;
	m_Value = _tcstod(szValue, &endptr);
}*/

////////////////////////////////////////////////////////////////////////
//
//  CSchemaBoolean
//
////////////////////////////////////////////////////////////////////////


class  CSchemaBoolean : public CSchemaTypeNumber, public CSchemaType
{
public:
	CSchemaBoolean() : m_Value(false) {};
	CSchemaBoolean(const bool value) : CSchemaType( false ), m_Value(value) {};
	CSchemaBoolean(const long value) : CSchemaType( false ), m_Value(value!=0) {};
	CSchemaBoolean(const TCHAR* szValue) { Parse(szValue); }
	CSchemaBoolean(const CSchemaType& rOther) { *this = rOther; }

	enum { TYPE = CSchemaType::k_bool };

	virtual operator bool() const			{ return m_bIsEmpty ? false	: m_Value; }
	long	ToCalcValue() const				{ return ToLong(); }
	/*virtual*/ CSchemaBoolean& operator=(const bool bValue)	{ m_bIsEmpty = false; m_Value = bValue; return *this; }	
	/*virtual*/ CSchemaBoolean& operator=(const CSchemaType& rOther)	{ return (CSchemaBoolean&)Assign(rOther); }

	// from CSchemaType
	virtual operator tstring() const;
	virtual bool ToBool() const				{ return m_bIsEmpty ? false	: m_Value; }

	void	Empty()		{ m_Value = false; m_bIsEmpty = true; }
	virtual void Parse(const TCHAR* szValue);
	virtual CSchemaType& Assign(const CSchemaType& rOther )				
	{ 
		m_bIsEmpty = ((CSchemaType&)rOther).IsEmpty(); 
		m_Value = rOther.ToBool();	
		return *this;
	}

	// from CSchemaTypeNumber
	virtual ETypes			NumericType() const	{ return (CSchemaType::ETypes)TYPE; }
	virtual long			ToLong() const		{ return m_bIsEmpty ? (long)0			: m_Value; }
	virtual LLONG	ToInt64() const		{ return m_bIsEmpty ? (LLONG)0	: m_Value; }
	virtual float			ToFloat() const		{ return m_bIsEmpty ? (float)0.0		: m_Value; }
	virtual double			ToDouble() const	{ return m_bIsEmpty ? (double)0.0		: m_Value; }

	typedef bool basetype;
	typedef long calctype;
protected:
	bool m_Value;
};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaTypeCalendar
//
////////////////////////////////////////////////////////////////////////

class CSchemaDuration;
class CSchemaTime;
class CSchemaDay;
class CSchemaMonth;
class CSchemaMonthDay;
class CSchemaYear;
class CSchemaYearMonth;
class CSchemaDate;
class CSchemaDateTime;


class  CSchemaTypeCalendar
{
public:
	virtual operator CSchemaDuration() const = 0;
	virtual operator CSchemaTime() const = 0;
	virtual operator CSchemaDay() const = 0;
	virtual operator CSchemaMonth() const = 0;
	virtual operator CSchemaMonthDay() const = 0;
	virtual operator CSchemaYear() const = 0;
	virtual operator CSchemaYearMonth() const = 0;
	virtual operator CSchemaDate() const = 0;
	virtual operator CSchemaDateTime() const = 0;

	virtual CSchemaType::ETypes CalendarType() const = 0;
};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaDuration
//
////////////////////////////////////////////////////////////////////////


class  CSchemaDuration : public CSchemaTypeCalendar, public CSchemaType
{
public:
	CSchemaDuration();
	CSchemaDuration(bool bPositive, int nYear, int nMonth, int nDay, int nHour, int nMinute, double dSecond);
	CSchemaDuration(const TCHAR* szValue);
	CSchemaDuration(const CSchemaType& rOther);

	enum { TYPE = CSchemaType::k_Duration };

	bool IsPositive() const;
	int GetYear() const;
	int GetMonth() const;
	int GetDay() const;
	int GetHour() const;
	int GetMinute() const;
	double GetSecond() const;

	void SetPositive(bool bPositive);
	void SetYear(int nYear);
	void SetMonth(int nMonth);
	void SetDay(int nDay);
	void SetHour(int nHour);
	void SetMinute(int nMinute);
	void SetSecond(double dSecond);

	/*virtual*/ CSchemaDuration& operator=(const CSchemaType& rOther )	{ return (CSchemaDuration&)Assign(rOther); }
	// --- modified ---
	// friend CSchemaType;
	friend class CSchemaType;
	// --- modified ---
	friend CSchemaDuration  operator+(const CSchemaDuration& dur1, const CSchemaDuration& dur2);

	// from CSchemaType
	virtual operator tstring() const;
	virtual bool ToBool() const;


	virtual void Parse(const TCHAR* szValue);
	virtual CSchemaType& Assign(const CSchemaType& rOther );
	virtual void Empty();

	// from CSchemaTypeCalendar
	virtual ETypes CalendarType() const	{ return (CSchemaType::ETypes)TYPE; }
	virtual operator CSchemaDuration() const;
	virtual operator CSchemaTime() const;
	virtual operator CSchemaDay() const;
	virtual operator CSchemaMonth() const;
	virtual operator CSchemaMonthDay() const;
	virtual operator CSchemaYear() const;
	virtual operator CSchemaYearMonth() const;
	virtual operator CSchemaDate() const;
	virtual operator CSchemaDateTime() const;

	typedef const TCHAR* basetype;
	#define	CSchemaDuration_BASETYPE_LPCTSTR
protected:
	double	ApproximatedNormalizedSeconds() const;	// approximated because assumed that 1 month=31 days; used only for comparison

	bool	m_bPositive;
	int		m_nYear;
	int		m_nMonth;
	int		m_nDay;
	int		m_nHour;
	int		m_nMinute;
	double	m_dSecond;
};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaDateTimeBase
//
////////////////////////////////////////////////////////////////////////


class  CSchemaDateTimeBase : public CSchemaType, public CSchemaTypeCalendar
{
public:
	CSchemaDateTimeBase();
	CSchemaDateTimeBase(bool bUTC);
	CSchemaDateTimeBase(int nOffset);

	bool HasTimezone() const;
	int GetTimezoneMode() const;
	int GetOffset() const;

	void SetTimezoneMode(int nTZMode);
	void SetOffset(int nOffset);

	enum
	{
		TZ_UTC,
		TZ_Offset,
		TZ_Missing
	};

protected:
	static int WriteTime(TCHAR* szTarget, int nHour, int nMinute, double dSecond);

	void ParseTZ(const TCHAR* szValue);
	void WriteTZ(TCHAR* szTarget) const;

	int				m_nTZMode;
	int				m_nOffset;
};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaDate
//
////////////////////////////////////////////////////////////////////////


class  CSchemaDate : public CSchemaDateTimeBase
{
public:
	CSchemaDate();
	CSchemaDate(int nYear, int nMonth, int nDay, bool bUTC = false);
	CSchemaDate(int nYear, int nMonth, int nDay, int nOffset);
	CSchemaDate(const TCHAR* szValue);
	CSchemaDate(const CSchemaType& rOther);

	enum { TYPE = CSchemaType::k_Date };

	int GetYear() const;
	int GetMonth() const;
	int GetDay() const;

	void SetYear(int nYear);
	void SetMonth(int nMonth);
	void SetDay(int nDay);

	friend bool  operator==(const CSchemaDate& t1, const CSchemaDate& t2);
	friend bool  operator< (const CSchemaDate& t1, const CSchemaDate& t2);
	friend bool  operator!=(const CSchemaDate& t1, const CSchemaDate& t2);
	friend bool  operator<=(const CSchemaDate& t1, const CSchemaDate& t2);
	friend bool  operator> (const CSchemaDate& t1, const CSchemaDate& t2);
	friend bool  operator>=(const CSchemaDate& t1, const CSchemaDate& t2);

	// --- modified ---
	// friend CSchemaType;
	friend class CSchemaType;
	// --- modified ---
	friend CSchemaDate  operator+(const CSchemaDate& t, const CSchemaDuration& dur);
	friend CSchemaDuration  operator-(const CSchemaDate& t1, const CSchemaDate& t2);
	/*virtual*/ CSchemaDate& operator=(const CSchemaType& rOther)	{ return (CSchemaDate&)Assign(rOther);	}

	// from CSchemaType
	virtual operator tstring() const;
	virtual bool ToBool() const;


	virtual void Parse(const TCHAR* szValue);
	virtual CSchemaType& Assign(const CSchemaType& rOther );
	virtual void Empty();

	// from CSchemaTypeCalendar
	virtual ETypes CalendarType() const	{ return (CSchemaType::ETypes)TYPE; }
	virtual operator CSchemaDuration() const;
	virtual operator CSchemaTime() const;
	virtual operator CSchemaDay() const;
	virtual operator CSchemaMonth() const;
	virtual operator CSchemaMonthDay() const;
	virtual operator CSchemaYear() const;
	virtual operator CSchemaYearMonth() const;
	virtual operator CSchemaDate() const;
	virtual operator CSchemaDateTime() const;

	typedef const TCHAR* basetype;
	#define	CSchemaDate_BASETYPE_LPCTSTR
protected:
	long	ApproximatedNormalizedDays() const;	// approx. because assumes 1 month = 31 days

	int		m_nYear;
	int		m_nMonth;
	int		m_nDay;
};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaTime
//
////////////////////////////////////////////////////////////////////////


class  CSchemaTime : public CSchemaDateTimeBase
{
public:
	CSchemaTime();
	CSchemaTime(int nHour, int nMinute, double dSecond, bool bUTC = false);
	CSchemaTime(int nHour, int nMinute, double dSecond, int nOffset);
	CSchemaTime(const TCHAR* szValue);
	CSchemaTime(const CSchemaType& rOther);

	enum { TYPE = CSchemaType::k_Time };

	int GetHour() const;
	int GetMinute() const;
	double GetSecond() const;

	void SetHour(int nHour);
	void SetMinute(int nMinute);
	void SetSecond(double dSecond);

	friend bool  operator< (const CSchemaTime& t1, const CSchemaTime& t2);
	friend bool  operator!=(const CSchemaTime& t1, const CSchemaTime& t2);
	friend bool  operator<=(const CSchemaTime& t1, const CSchemaTime& t2);
	friend bool  operator> (const CSchemaTime& t1, const CSchemaTime& t2);
	friend bool  operator>=(const CSchemaTime& t1, const CSchemaTime& t2);

	// --- modified ---
	// friend CSchemaType;
	friend class CSchemaType;
	// --- modified ---
	friend CSchemaTime  operator+(const CSchemaTime& t, const CSchemaDuration& dur);
	friend CSchemaDuration  operator-(const CSchemaTime& t1, const CSchemaTime& t2);
	/*virtual*/ CSchemaTime& operator=(const CSchemaType& rOther )	{ return (CSchemaTime&)Assign(rOther); }

	// from CSchemaType
	virtual operator tstring() const;
	virtual bool ToBool() const;


	virtual void Parse(const TCHAR* szValue);
	virtual CSchemaType& Assign(const CSchemaType& rOther );
	virtual void Empty();

	// from CSchemaTypeCalendar
	virtual ETypes CalendarType() const	{ return (CSchemaType::ETypes)TYPE; }
	virtual operator CSchemaDuration() const;
	virtual operator CSchemaTime() const;
	virtual operator CSchemaDay() const;
	virtual operator CSchemaMonth() const;
	virtual operator CSchemaMonthDay() const;
	virtual operator CSchemaYear() const;
	virtual operator CSchemaYearMonth() const;
	virtual operator CSchemaDate() const;
	virtual operator CSchemaDateTime() const;

	typedef const TCHAR* basetype;
	#define	CSchemaTime_BASETYPE_LPCTSTR
//protected:
public:
	double NormalizedSeconds() const;

	int		m_nHour;
	int		m_nMinute;
	double	m_dSecond;
};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaDateTime
//
////////////////////////////////////////////////////////////////////////


class  CSchemaDateTime : public CSchemaDateTimeBase
{
public:
	CSchemaDateTime();
	CSchemaDateTime(int nYear, int nMonth, int nDay, int nHour, int nMinute, double dSecond, bool bUTC = false);
	CSchemaDateTime(int nYear, int nMonth, int nDay, int nHour, int nMinute, double dSecond, int nOffset);
	CSchemaDateTime(const TCHAR* szValue);
	CSchemaDateTime(const CSchemaType& rOther);


	enum { TYPE = CSchemaType::k_DateTime };

	int GetYear() const;
	int GetMonth() const;
	int GetDay() const;
	int GetHour() const;
	int GetMinute() const;
	double GetSecond() const;

	void SetYear(int nYear);
	void SetMonth(int nMonth);
	void SetDay(int nDay);
	void SetHour(int nHour);
	void SetMinute(int nMinute);
	void SetSecond(double dSecond);

	friend bool  operator==(const CSchemaDateTime& t1, const CSchemaDateTime& t2);
	friend bool  operator< (const CSchemaDateTime& t1, const CSchemaDateTime& t2);
	friend bool  operator!=(const CSchemaDateTime& t1, const CSchemaDateTime& t2);
	friend bool  operator<=(const CSchemaDateTime& t1, const CSchemaDateTime& t2);
	friend bool  operator> (const CSchemaDateTime& t1, const CSchemaDateTime& t2);
	friend bool  operator>=(const CSchemaDateTime& t1, const CSchemaDateTime& t2);

	// --- modified ---
//	friend CSchemaType;
	friend class CSchemaType;
	// --- modified ---

	friend CSchemaDateTime  operator+(const CSchemaDateTime& t, const CSchemaDuration& dur);
	friend CSchemaDuration  operator-(const CSchemaDateTime& t1, const CSchemaDateTime& t2);
	/*virtual*/ CSchemaDateTime& operator=(const CSchemaType& rOther)	{ return (CSchemaDateTime&)Assign(rOther);	}

	// from CSchemaType
	virtual operator tstring() const;
	virtual bool ToBool() const;

	virtual void Parse(const TCHAR* szValue);
	virtual CSchemaType& Assign(const CSchemaType& rOther );
	virtual void Empty();

	// from CSchemaTypeCalendar
	virtual ETypes CalendarType() const	{ return (CSchemaType::ETypes)TYPE; }
	virtual operator CSchemaDuration() const;
	virtual operator CSchemaTime() const;
	virtual operator CSchemaDay() const;
	virtual operator CSchemaMonth() const;
	virtual operator CSchemaMonthDay() const;
	virtual operator CSchemaYear() const;
	virtual operator CSchemaYearMonth() const;
	virtual operator CSchemaDate() const;
	virtual operator CSchemaDateTime() const;


	typedef const TCHAR* basetype;
	#define	CSchemaDateTime_BASETYPE_LPCTSTR
protected:
	double	ApproximatedNormalizedSeconds() const;	// approximated because assumes 1 month = 31 days;

	int		m_nYear;
	int		m_nMonth;
	int		m_nDay;

	int		m_nHour;
	int		m_nMinute;
	double	m_dSecond;
};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaYear
//
////////////////////////////////////////////////////////////////////////


class  CSchemaYear : public CSchemaDateTimeBase
{
public:
	CSchemaYear();
	CSchemaYear(int nYear, bool bUTC = false);
	CSchemaYear(int nYear, int nOffset);
	CSchemaYear(const TCHAR* szValue);
	CSchemaYear(const CSchemaType& rOther);

	enum { TYPE = CSchemaType::k_Year };

	int GetYear() const;
	void SetYear(int nYear);

	// --- modified ---
	// friend CSchemaType;
	friend class CSchemaType;
	// --- modified ---
	/*virtual*/ CSchemaYear& operator=(const CSchemaType& rOther)	{ return (CSchemaYear&)Assign(rOther); }

	// from CSchemaType
	virtual operator tstring() const;
	virtual bool ToBool() const;


	virtual void Parse(const TCHAR* szValue);
	virtual CSchemaType& Assign(const CSchemaType& rOther );
	virtual void Empty();

	// from CSchemaTypeCalendar
	virtual ETypes CalendarType() const	{ return (CSchemaType::ETypes)TYPE; }
	virtual operator CSchemaDuration() const;
	virtual operator CSchemaTime() const;
	virtual operator CSchemaDay() const;
	virtual operator CSchemaMonth() const;
	virtual operator CSchemaMonthDay() const;
	virtual operator CSchemaYear() const;
	virtual operator CSchemaYearMonth() const;
	virtual operator CSchemaDate() const;
	virtual operator CSchemaDateTime() const;

	typedef const TCHAR* basetype;
	#define	CSchemaYear_BASETYPE_LPCTSTR
protected:
	int		m_nYear;
};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaYearMonth
//
////////////////////////////////////////////////////////////////////////


class  CSchemaYearMonth : public CSchemaDateTimeBase
{
public:
	CSchemaYearMonth();
	CSchemaYearMonth(int nYear, int nMonth, bool bUTC = false);
	CSchemaYearMonth(int nYear, int nMonth, int nOffset);
	CSchemaYearMonth(const TCHAR* szValue);
	CSchemaYearMonth(const CSchemaType& rOther);

	enum { TYPE = CSchemaType::k_YearMonth };

	int GetYear() const;
	int GetMonth() const;

	void SetYear(int nYear);
	void SetMonth(int nMonth);

	// --- modified ---
	// friend CSchemaType;
	friend class CSchemaType;
	// --- modified ---

	/*virtual*/ CSchemaYearMonth& operator=(const CSchemaType& rOther)	{ return (CSchemaYearMonth&)Assign(rOther); }

	// from CSchemaType
	virtual operator tstring() const;
	virtual bool ToBool() const;


	virtual void Parse(const TCHAR* szValue);
	virtual CSchemaType& Assign(const CSchemaType& rOther );
	virtual void Empty();

	// from CSchemaTypeCalendar
	virtual ETypes CalendarType() const	{ return (CSchemaType::ETypes)TYPE; }
	virtual operator CSchemaDuration() const;
	virtual operator CSchemaTime() const;
	virtual operator CSchemaDay() const;
	virtual operator CSchemaMonth() const;
	virtual operator CSchemaMonthDay() const;
	virtual operator CSchemaYear() const;
	virtual operator CSchemaYearMonth() const;
	virtual operator CSchemaDate() const;
	virtual operator CSchemaDateTime() const;


	typedef const TCHAR* basetype;
	#define	CSchemaYearMonth_BASETYPE_LPCTSTR
protected:
	long	NormalizedMonths() const;

	int		m_nYear;
	int		m_nMonth;
};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaMonth
//
////////////////////////////////////////////////////////////////////////


class  CSchemaMonth : public CSchemaDateTimeBase
{
public:
	CSchemaMonth();
	CSchemaMonth(int nMonth, bool bUTC = false);
	CSchemaMonth(int nMonth, int nOffset);
	CSchemaMonth(const TCHAR* szValue);
	CSchemaMonth(const CSchemaType& rOther);

	enum { TYPE = CSchemaType::k_Month };

	int GetMonth() const;
	void SetMonth(int nMonth);

	// --- modified ---
	// friend CSchemaType;
	friend class CSchemaType;
	// --- modified ---
	/*virtual*/ CSchemaMonth& operator=(const CSchemaType& rOther )	{ return (CSchemaMonth&)Assign(rOther); }

	// from CSchemaType
	virtual operator tstring() const;
	virtual bool ToBool() const;


	virtual void Parse(const TCHAR* szValue);
	virtual CSchemaType& Assign(const CSchemaType& rOther );
	virtual void Empty();

	// from CSchemaTypeCalendar
	virtual ETypes CalendarType() const	{ return (CSchemaType::ETypes)TYPE; }
	virtual operator CSchemaDuration() const;
	virtual operator CSchemaTime() const;
	virtual operator CSchemaDay() const;
	virtual operator CSchemaMonth() const;
	virtual operator CSchemaMonthDay() const;
	virtual operator CSchemaYear() const;
	virtual operator CSchemaYearMonth() const;
	virtual operator CSchemaDate() const;
	virtual operator CSchemaDateTime() const;


	typedef const TCHAR* basetype;
	#define	CSchemaMonth_BASETYPE_LPCTSTR
protected:
	int		m_nMonth;
};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaMonthDay
//
////////////////////////////////////////////////////////////////////////


class  CSchemaMonthDay : public CSchemaDateTimeBase
{
public:
	CSchemaMonthDay();
	CSchemaMonthDay(int nMonth, int nDay, bool bUTC = false);
	CSchemaMonthDay(int nMonth, int nDay, int nOffset);
	CSchemaMonthDay(const TCHAR* szValue);
	CSchemaMonthDay(const CSchemaType& rOther);

	enum { TYPE = CSchemaType::k_MonthDay };

	int GetMonth() const;
	int GetDay() const;

	void SetMonth(int nMonth);
	void SetDay(int nYear);

	// --- modified ---
	// friend CSchemaType;
	friend class CSchemaType;
	// --- modified ---
	/*virtual*/ CSchemaMonthDay& operator=(const CSchemaType& rOther)	{ return (CSchemaMonthDay&)Assign(rOther);	}

	// from CSchemaType
	virtual operator tstring() const;
	virtual bool ToBool() const;


	virtual void Parse(const TCHAR* szValue);
	virtual CSchemaType& Assign(const CSchemaType& rOther );
	virtual void Empty();

	// from CSchemaTypeCalendar
	virtual ETypes CalendarType() const	{ return (CSchemaType::ETypes)TYPE; }
	virtual operator CSchemaDuration() const;
	virtual operator CSchemaTime() const;
	virtual operator CSchemaDay() const;
	virtual operator CSchemaMonth() const;
	virtual operator CSchemaMonthDay() const;
	virtual operator CSchemaYear() const;
	virtual operator CSchemaYearMonth() const;
	virtual operator CSchemaDate() const;
	virtual operator CSchemaDateTime() const;


	typedef const TCHAR* basetype;
	#define	CSchemaMonthDay_BASETYPE_LPCTSTR
protected:
	long	ApproximatedNormalizedDays() const;		// approx. 'cause assumes 1 month = 31 days; for comparison only

	int		m_nMonth;
	int		m_nDay;
};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaDay
//
////////////////////////////////////////////////////////////////////////


class  CSchemaDay : public CSchemaDateTimeBase
{
public:
	CSchemaDay();
	CSchemaDay(int nDay, bool bUTC = false);
	CSchemaDay(int nDay, int nOffset);
	CSchemaDay(const TCHAR* szValue);
	CSchemaDay(const CSchemaType& rOther);

	enum { TYPE = CSchemaType::k_Day };

	int GetDay() const;

	void SetDay(int nYear);

	// --- modified --- 
	// friend CSchemaType;
	friend class CSchemaType;
	// --- modified --- 
	/*virtual*/ CSchemaDay& operator=(const CSchemaType& rOther)	{ return (CSchemaDay&)Assign(rOther);	}

	// from CSchemaType
	virtual operator tstring() const;
	virtual bool ToBool() const;


	virtual void Parse(const TCHAR* szValue);
	virtual CSchemaType& Assign(const CSchemaType& rOther );
	virtual void Empty();

	// from CSchemaTypeCalendar
	virtual ETypes CalendarType() const	{ return (CSchemaType::ETypes)TYPE; }
	virtual operator CSchemaDuration() const;
	virtual operator CSchemaTime() const;
	virtual operator CSchemaDay() const;
	virtual operator CSchemaMonth() const;
	virtual operator CSchemaMonthDay() const;
	virtual operator CSchemaYear() const;
	virtual operator CSchemaYearMonth() const;
	virtual operator CSchemaDate() const;
	virtual operator CSchemaDateTime() const;


	typedef const TCHAR* basetype;
	#define	CSchemaDay_BASETYPE_LPCTSTR
protected:
	int		m_nDay;
};



////////////////////////////////////////////////////////////////////////
//
//  CSchemaString family
//
////////////////////////////////////////////////////////////////////////


class  CSchemaString : public CSchemaType, public CSchemaTypeNumber, public CSchemaTypeCalendar
{
public:
	CSchemaString();
	CSchemaString(const tstring sValue);
	CSchemaString(const TCHAR* szValue);
	CSchemaString(const double	nValue);	// numeric value will be transformed into a string-representation
	CSchemaString(const CSchemaType& rOther);

	enum { TYPE = CSchemaType::k_String };

	// --- modified ---
	// friend CSchemaType;
	friend class CSchemaType;
	// --- modified ---
	/*virtual*/ CSchemaString& operator=(const CSchemaType& rOther)	{ return (CSchemaString&)Assign(rOther); }

	double ToCalcValue() const	{ return ToDouble(); }
	static CSchemaType* CreateInstanceByString(const TCHAR* szValue);


	// from CSchemaType
	virtual operator tstring() const;
	virtual bool ToBool() const;
	virtual void Parse(const TCHAR* szValue);
	virtual CSchemaType& Assign(const CSchemaType& rOther);
	virtual void Empty();

	// from CSchemaTypeNumber
	virtual ETypes				NumericType() const;
	virtual long				ToLong() const;
	virtual LLONG		ToInt64() const;
	virtual float				ToFloat() const;
	virtual double				ToDouble() const;

	// from CSchemaTypeCalendar 
	virtual ETypes		CalendarType() const;
	virtual operator CSchemaDuration() const;
	virtual operator CSchemaTime() const;
	virtual operator CSchemaDay() const;
	virtual operator CSchemaMonth() const;
	virtual operator CSchemaMonthDay() const;
	virtual operator CSchemaYear() const;
	virtual operator CSchemaYearMonth() const;
	virtual operator CSchemaDate() const;
	virtual operator CSchemaDateTime() const;


	typedef const TCHAR* basetype;
	#define	CSchemaString_BASETYPE_LPCTSTR
//	typedef double	calctype;	// string values are represented as double-values if possible.

protected:
	tstring m_Value;
};


/*typedef CSchemaString CSchemaNormalizedString;
typedef CSchemaString CSchemaToken;
typedef CSchemaString CSchemaLanguage;
typedef CSchemaString CSchemaName;
typedef CSchemaString CSchemaNMToken;
typedef CSchemaString CSchemaNMTokens;
typedef CSchemaString CSchemaNCName;
typedef CSchemaString CSchemaID;
typedef CSchemaString CSchemaIDRef;
typedef CSchemaString CSchemaIDRefs;
typedef CSchemaString CSchemaEntity;
typedef CSchemaString CSchemaEntities;
typedef CSchemaString CSchemaAnyURI;
typedef CSchemaString CSchemaQName;
typedef CSchemaString CSchemaNotation;

#define CSchemaNormalizedString_BASETYPE_LPCTSTR
#define CSchemaToken_BASETYPE_LPCTSTR
#define CSchemaLanguage_BASETYPE_LPCTSTR
#define CSchemaName_BASETYPE_LPCTSTR
#define CSchemaNMToken_BASETYPE_LPCTSTR
#define CSchemaNMTokens_BASETYPE_LPCTSTR
#define CSchemaNCName_BASETYPE_LPCTSTR
#define CSchemaID_BASETYPE_LPCTSTR
#define CSchemaIDRef_BASETYPE_LPCTSTR
#define CSchemaIDRefs_BASETYPE_LPCTSTR
#define CSchemaEntity_BASETYPE_LPCTSTR
#define CSchemaEntities_BASETYPE_LPCTSTR
#define CSchemaAnyURI_BASETYPE_LPCTSTR
#define CSchemaQName_BASETYPE_LPCTSTR
#define CSchemaNotation_BASETYPE_LPCTSTR*/


////////////////////////////////////////////////////////////////////////
//
//  CSchemaBinaryBase
//
////////////////////////////////////////////////////////////////////////


class  CSchemaBinaryBase : public CSchemaType
{
public:
//	CSchemaBinaryBase() : m_nSize(0), m_pData(NULL)  {};
	CSchemaBinaryBase() : m_pData(NULL), m_nSize(0) {};
	CSchemaBinaryBase(const CSchemaBinaryBase& rOther);
	CSchemaBinaryBase(const unsigned char* pData, int nSize);
	virtual ~CSchemaBinaryBase();

	int GetSize() const						{ return m_nSize; }
	const unsigned char* GetData() const	{ return m_pData; }
	unsigned char* GetData()				{ return m_pData; }

	void SetData(const unsigned char* pData, int nSize);

	// --- modified ---
	// friend CSchemaType;
	friend class CSchemaType;
	// --- modified ---

	// from CSchemaType
	virtual operator tstring() const = 0;
	virtual bool ToBool() const	{	return !( m_bIsEmpty || m_pData == NULL );	}

	virtual void Parse(const TCHAR* szValue) = 0;
	virtual CSchemaType& Assign(const CSchemaType& rOther);
	virtual void Empty();

	typedef const TCHAR* basetype;
	#define	CSchemaBinaryBase_BASETYPE_LPCTSTR
protected:
	void Clone(const CSchemaBinaryBase& rOther);
	void Clone(const unsigned char* pData, int nSize);

	unsigned char*	m_pData;
	int				m_nSize;

//	int				m_nSize;
//	unsigned char*	m_pData;

};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaHexBinary
//
////////////////////////////////////////////////////////////////////////


class  CSchemaHexBinary : public CSchemaBinaryBase
{
public:
	CSchemaHexBinary() {};
	CSchemaHexBinary(const CSchemaBinaryBase& rOther) : CSchemaBinaryBase(rOther) {};
	CSchemaHexBinary(const unsigned char* pData, int nSize) : CSchemaBinaryBase(pData, nSize) {};
	CSchemaHexBinary(const TCHAR* szValue);
	CSchemaHexBinary(const CSchemaType& rOther);

	enum { TYPE = CSchemaType::k_HexBinary };

	// --- modified ---
  	// friend CSchemaType;
	friend class CSchemaType;
	// --- modified ---

	/*virtual*/ CSchemaHexBinary& operator=(const CSchemaType& rOther) { return (CSchemaHexBinary&)Assign(rOther); }
	/*virtual*/ CSchemaHexBinary& operator=(const CSchemaHexBinary& rOther)	{ return (CSchemaHexBinary&)Assign(rOther); }

	// from CSchemaType
	virtual operator tstring() const;

	virtual void Parse(const TCHAR* szValue);

	typedef const TCHAR* basetype;
	#define	CSchemaHexBinary_BASETYPE_LPCTSTR
protected:
	static const TCHAR	sm_EncodeArray[];
	static const char	sm_DecodeArray[];
};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaBase64Binary
//
////////////////////////////////////////////////////////////////////////


class  CSchemaBase64Binary : public CSchemaBinaryBase
{
public:
	CSchemaBase64Binary()  {};
	CSchemaBase64Binary(const CSchemaBinaryBase& rOther) : CSchemaBinaryBase(rOther ) {};
	CSchemaBase64Binary(const unsigned char* pData, int nSize) : CSchemaBinaryBase(pData, nSize) {};
	CSchemaBase64Binary(const TCHAR* szValue);
	CSchemaBase64Binary(const CSchemaType& rOther);

	enum { TYPE = CSchemaType::k_Base64Binary };

	// --- modified ---	
	// friend CSchemaType;
	friend class CSchemaType;
	// --- modified ---
	
	/*virtual*/ CSchemaBase64Binary& operator=(const CSchemaType& rOther)	{ return (CSchemaBase64Binary&)Assign(rOther); }
	/*virtual*/ CSchemaBase64Binary& operator=(const CSchemaBase64Binary& rOther)	{ return (CSchemaBase64Binary&)Assign(rOther); }

	// from CSchemaType
	virtual operator tstring() const;

	virtual void Parse(const TCHAR* szValue);

	typedef const TCHAR* basetype;
	#define	CSchemaBase64Binary_BASETYPE_LPCTSTR
protected:
	void Encode(unsigned char* pSrc, int nSrcSize, TCHAR*& rszDst, int& rnDstSize, int nMaxLineLength = 76) const;
	void Decode(const TCHAR* szSrc, unsigned char*& rpDst, int& rnDstSize);

	static const TCHAR	sm_EncodeArray[];
	static const char 	sm_DecodeArray[];
};


} // namespace mcml

#endif // MCML_SCHEMATYPES_H_INCLUDED
