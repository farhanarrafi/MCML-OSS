////////////////////////////////////////////////////////////////////////
//
// SchemaTypes.cpp
//
// This file was generated by XMLSPY 2004 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSPY Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#include "SchemaTypes.h"
#include "XMLException.h"
#include <math.h>
#include <time.h>


namespace mcml {


////////////////////////////////////////////////////////////////////////
//
//  Utility functions
//
////////////////////////////////////////////////////////////////////////


#define ThrowFormatError() \
	throw CXMLException(CXMLException::eError1, _T("Format error"));

#define ThrowIncompatibleTypesError() \
	throw CXMLException(CXMLException::eError1, _T("Types incompatible!"));

#define ThrowValuesNotConvertableError() \
	throw CXMLException(CXMLException::eError1, _T("Values are not convertable"));


int ParseInt(const TCHAR** pszData)
{
	TCHAR* szEndPtr;
	int n = _tcstol(*pszData, &szEndPtr, 10);
	if (*pszData == szEndPtr)
		ThrowFormatError();
	*pszData = szEndPtr;
	return n;
}


double ParseDouble(const TCHAR** pszData)
{
	TCHAR* szEndPtr;
	double d = _tcstod(*pszData, &szEndPtr);
	if (*pszData == szEndPtr)
		ThrowFormatError();
	*pszData = szEndPtr;
	return d;
}


void ParseChar(const TCHAR** pszData, TCHAR chValue)
{
	if (**pszData != chValue)
		ThrowFormatError();
	(*pszData)++;
}


inline double fQuotient(double a, double b)
{
	return floor(a / b);
}


inline double fQuotient(double a, double low, double high)
{
	return fQuotient(a - low, high - low);
}


inline double modulo(double a, double b)
{
	return a - fQuotient(a, b) * b;
}


inline double modulo(double a, double low, double high)
{
	return modulo(a - low, high - low) + low;
}


inline bool isLeapYear(int year)
{
	return (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0));
}


int maxDayInMonthFor(int year, int month)
{
	if (month == 4 || month == 6 || month == 9 || month == 11)
		return 30;
	else if (month == 2)
		return isLeapYear(year) ? 29 : 28;
	else
		return 31;
}


void DateTimeAddDuration(int& nYear, int& nMonth, int& nDay, int& nHour, int& nMinute, double& dSecond, const CSchemaDuration& dur)
{
	double temp, carry;

	temp = nMonth + dur.GetMonth();
	nMonth = modulo(temp, 1, 13);
	carry = fQuotient(temp, 1, 13);

	nYear += dur.GetYear() + carry;

	temp = dSecond + dur.GetSecond();
	dSecond = modulo(temp, 60);
	carry = fQuotient(temp, 60);

	temp = nMinute + dur.GetMinute() + carry;
	nMinute = modulo(temp, 60);
	carry = fQuotient(temp, 60);

	temp = nHour + dur.GetHour() + carry;
	nHour = modulo(temp, 24);
	carry = fQuotient(temp, 24);

	temp = maxDayInMonthFor(nYear, nMonth);
	if (nDay <= temp)
		temp = nDay < 1 ? 1 : nDay;
	nDay = temp + dur.GetDay() + carry;

	while (true)
	{
		temp = maxDayInMonthFor(nYear, nMonth);
		if (nDay < 1)
		{
			nDay += maxDayInMonthFor(nYear, nMonth - 1);
			carry = -1;
		}
		else if (nDay > temp)
		{
			nDay -= temp;
			carry = 1;
		}
		else
		{
			break;
		}

		temp = nMonth + carry;
		nMonth = modulo(temp, 1, 13);
		nYear += fQuotient(temp, 1, 13);
	}
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaBoolean
//
////////////////////////////////////////////////////////////////////////


CSchemaBoolean::operator tstring() const
{
	if( m_bIsEmpty )
		return _T("");
	return m_Value ? _T("true") : _T("false");
}


void CSchemaBoolean::Parse(const TCHAR* szValue)
{
	if( szValue[0] == 0 )
	{
		Empty();
		return;
	}
	m_bIsEmpty = false;
	m_Value = _tcscmp(szValue, _T("true")) == 0 || _tcscmp(szValue, _T("1")) == 0;
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaString
//
////////////////////////////////////////////////////////////////////////


CSchemaString::CSchemaString()
: m_Value(_T(""))
{
}


CSchemaString::CSchemaString(tstring sValue) 
: CSchemaType(false)
, m_Value(sValue)
{
}


CSchemaString::CSchemaString(const TCHAR* szValue) 
: CSchemaType(false)
, m_Value(szValue)
{
}


CSchemaString::CSchemaString(const double nValue)
: CSchemaType(false)
{
	m_Value = (tstring)CSchemaDecimal(nValue);
}

CSchemaString::CSchemaString(const CSchemaType& rObject)
{
	*this = rObject;
}



CSchemaString::operator tstring() const
{
	if( m_bIsEmpty )
		return _T("");
	return m_Value;
}

bool CSchemaString::ToBool() const
{
	if( m_bIsEmpty  ||
		m_Value.length() == 0  ||
		m_Value == _T("0")  ||		// Hack because of confuse boolean-value handling of XPATH 1.0
		m_Value == _T("false") )	//   --,,--
		return false;
	return true;
}


CSchemaType::ETypes CSchemaString::NumericType() const
{
	if( m_Value.length()==0 )
		return CSchemaType::k_unknown;
	
	TCHAR* szEndPtr;
	const TCHAR* szData = m_Value.c_str();

	// check if boolean
	if( m_Value == _T("true") || m_Value == _T("false") )
		return CSchemaType::k_bool;

	// check if integer 
	LLONG i64 = _ttoi64(szData);
	if( i64 > _I64_MAX )
		return CSchemaType::k_unsigned_long;
	// --- modified ---
	//if( i64 < _I32_MIN  ||
	//	  i64 > _UI32_MAX )
	if( i64 < (LLONG)(_I32_MIN) || i64 > (LLONG)(_UI32_MAX) )
	// --- modified ---
		return CSchemaType::k_long;
	long i = _tcstol(szData, &szEndPtr, 10);
	if( *szEndPtr == 0 )
	{	
		if( i < 0 )
		{	// signed
			if( i >= SCHAR_MIN )
				return CSchemaType::k_byte;
			if( i >= SHRT_MIN )
				return CSchemaType::k_short;
			return CSchemaType::k_int;
		}
		else
		{	// unsigned
			if( i <= UCHAR_MAX )
				return CSchemaType::k_unsigned_byte;
			if( i <= USHRT_MAX )
				return CSchemaType::k_unsigned_short;
			return CSchemaType::k_unsigned_int;
		}
	}

	// check floating-point
	// --- deleted(unused variable d) ---
	// double d = _tcstod(szData, &szEndPtr);
	// --- deleted ---
	if( *szEndPtr == 0 )
	{
		return CSchemaType::k_double;
		// NOTE: float and decimal are missing here.
	}

	// it is not a number
	return CSchemaType::k_unknown;
}


long CSchemaString::ToLong() const
{
	if( m_bIsEmpty )
		return (long)CSchemaInt();
	if( m_Value == _T("false") )
		return 0;
	if( m_Value == _T("true") )
		return 1;
	return (long)CSchemaInt(m_Value.c_str());
}

LLONG CSchemaString::ToInt64() const
{
	if( m_bIsEmpty )
		return (LLONG)CSchemaLong();
	if( m_Value == _T("false") )
		return 0;
	if( m_Value == _T("true") )
		return 1;
	return (LLONG)CSchemaLong(m_Value.c_str());
}

float CSchemaString::ToFloat() const
{
	if( m_bIsEmpty )
		return (float)CSchemaFloat();
	if( m_Value == _T("false") )
		return 0.0;
	if( m_Value == _T("true") )
		return 1.0;
	return (float)CSchemaFloat(m_Value.c_str());
}

double CSchemaString::ToDouble() const
{
	if( m_bIsEmpty )
		return (double)CSchemaDouble();
	if( m_Value == _T("false") )
		return 0.0;
	if( m_Value == _T("true") )
		return 1.0;
	return (double)CSchemaDouble(m_Value.c_str());
}



CSchemaType::ETypes CSchemaString::CalendarType() const
{
	if( m_Value.length()==0 )
		return CSchemaType::k_unknown;
	
	try
	{
		CSchemaDateTime r = CSchemaDateTime(m_Value.c_str());
		return CSchemaType::k_DateTime;	
	}
	catch( CXMLException e ) {};

	try
	{
		CSchemaDuration r = CSchemaDuration(m_Value.c_str());
		return CSchemaType::k_Duration;
	}
	catch( CXMLException e ) {};

	try
	{
		CSchemaDate r = CSchemaDate(m_Value.c_str());
		return CSchemaType::k_Date;
	}
	catch( CXMLException e ) {};

	try
	{
		CSchemaTime r = CSchemaTime(m_Value.c_str());
		return CSchemaType::k_Time;
	}
	catch( CXMLException e ) {};

	try
	{
		CSchemaYearMonth r = CSchemaYearMonth(m_Value.c_str());
		return CSchemaType::k_YearMonth;
	}
	catch( CXMLException e ) {};

	try
	{
		CSchemaMonthDay r = CSchemaMonthDay(m_Value.c_str());
		return CSchemaType::k_MonthDay;
	}
	catch( CXMLException e ) {};

	try
	{
		CSchemaDay r = CSchemaDay(m_Value.c_str());
		return CSchemaType::k_Day;
	}
	catch( CXMLException e ) {};

	try
	{
		CSchemaMonth r = CSchemaMonth(m_Value.c_str());
		return CSchemaType::k_Month;
	}
	catch( CXMLException e ) {};

	try
	{
		CSchemaYear r = CSchemaYear(m_Value.c_str());
		return CSchemaType::k_Year;
	}
	catch( CXMLException e ) {};

	return CSchemaType::k_unknown;
}

CSchemaString::operator CSchemaDate() const
{
	if( m_bIsEmpty )
		return CSchemaDate();
	return CSchemaDate(m_Value.c_str());
}

CSchemaString::operator CSchemaDateTime() const
{
	if( m_bIsEmpty )
		return CSchemaDateTime();
	return CSchemaDateTime(m_Value.c_str());
}

CSchemaString::operator CSchemaDay() const
{
	if( m_bIsEmpty )
		return CSchemaDay();
	return CSchemaDay(m_Value.c_str());
}

CSchemaString::operator CSchemaDuration() const
{
	if( m_bIsEmpty )
		return CSchemaDuration();
	return CSchemaDuration(m_Value.c_str());
}

CSchemaString::operator CSchemaMonth() const
{
	if( m_bIsEmpty )
		return CSchemaMonth();
	return CSchemaMonth(m_Value.c_str());
}

CSchemaString::operator CSchemaMonthDay() const
{
	if( m_bIsEmpty )
		return CSchemaMonthDay();
	return CSchemaMonthDay(m_Value.c_str());
}

CSchemaString::operator CSchemaTime() const
{
	if( m_bIsEmpty )
		return CSchemaTime();
	return CSchemaTime(m_Value.c_str());
}

CSchemaString::operator CSchemaYear() const
{
	if( m_bIsEmpty )
		return CSchemaYear();
	return CSchemaYear(m_Value.c_str());
}

CSchemaString::operator CSchemaYearMonth() const
{
	if( m_bIsEmpty )
		return CSchemaYearMonth();
	return CSchemaYearMonth(m_Value.c_str());
}


void CSchemaString::Parse(const TCHAR* szValue)
{
	m_Value = szValue;
	m_bIsEmpty = false;
}

CSchemaType& CSchemaString::Assign(const CSchemaType& rObject)
{
	m_Value = (tstring)rObject;
	m_bIsEmpty = rObject.IsEmpty();
	return *this;
}

void CSchemaString::Empty()
{
	m_Value = _T("");
	m_bIsEmpty = true;
}


CSchemaType* CSchemaString::CreateInstanceByString(const TCHAR* szValue)
{
	// check if it is boolean
	if( _tcscmp(szValue, _T("false")) == 0 )
		return new CSchemaBoolean(false);
	if( _tcscmp(szValue, _T("true")) == 0 )
		return new CSchemaBoolean(true);

	CSchemaString	tmp(szValue);
	// check if it is a number
	switch( tmp.NumericType() )
	{
	case CSchemaType::k_byte:			return new CSchemaByte(szValue);
	case CSchemaType::k_unsigned_byte:	return new CSchemaUnsignedByte(szValue);
	case CSchemaType::k_short:			return new CSchemaShort(szValue);
	case CSchemaType::k_unsigned_short:	return new CSchemaUnsignedShort(szValue);
	case CSchemaType::k_int:			return new CSchemaInt(szValue);
	case CSchemaType::k_unsigned_int:	return new CSchemaUnsignedInt(szValue);
	case CSchemaType::k_long:			return new CSchemaLong(szValue);
	case CSchemaType::k_unsigned_long:	return new CSchemaUnsignedLong(szValue);
	case CSchemaType::k_float:			return new CSchemaFloat(szValue);
	case CSchemaType::k_double:			return new CSchemaDouble(szValue);
	case CSchemaType::k_unknown:
	default:
		// check if it is a calendar
		switch( tmp.CalendarType() )
		{
		case CSchemaType::k_Date:		return new CSchemaDate(szValue);
		case CSchemaType::k_DateTime:	return new CSchemaDateTime(szValue);
		case CSchemaType::k_Day:		return new CSchemaDay(szValue);
		case CSchemaType::k_Duration:	return new CSchemaDuration(szValue);
		case CSchemaType::k_Month:		return new CSchemaMonth(szValue);
		case CSchemaType::k_MonthDay:	return new CSchemaMonthDay(szValue);
		case CSchemaType::k_Time:		return new CSchemaTime(szValue);
		case CSchemaType::k_Year:		return new CSchemaYear(szValue);
		case CSchemaType::k_YearMonth:	return new CSchemaYearMonth(szValue);
		case CSchemaType::k_unknown:
		default:
			;// TODO - check if it is a binary-datatype
		}
	}
	return new CSchemaString(szValue);
}



////////////////////////////////////////////////////////////////////////
//
//  CSchemaDuration
//
////////////////////////////////////////////////////////////////////////


CSchemaDuration::CSchemaDuration()	
{
	Empty();
}


CSchemaDuration::CSchemaDuration(bool bPositive, int nYear, int nMonth, int nDay, int nHour, int nMinute, double dSecond)
{
	m_bIsEmpty = false;
	m_bPositive	= bPositive;
	m_nYear		= nYear;
	m_nMonth	= nMonth;
	m_nDay		= nDay;
	m_nHour		= nHour;
	m_nMinute	= nMinute;
	m_dSecond	= dSecond;
}


CSchemaDuration::CSchemaDuration(const TCHAR* szValue)
{
	Parse(szValue);
}


CSchemaDuration::CSchemaDuration(const CSchemaType& rObject)
{
	Assign( rObject );
}


CSchemaDuration::operator tstring() const
{
	if( m_bIsEmpty )
		return _T("");
	TCHAR szResult[64];
	TCHAR* szTmp = szResult;

	if (!m_bPositive)
		*szTmp++ = _T('-');
	*szTmp++ = _T('P');
	if (m_nYear != 0)
		szTmp += _stprintf(szTmp, _T("%iY"), abs(m_nYear));
	if (m_nMonth != 0)
		szTmp += _stprintf(szTmp, _T("%iM"), abs(m_nMonth));
	if (m_nDay != 0)
		szTmp += _stprintf(szTmp, _T("%iD"), abs(m_nDay));
	if (m_nHour != 0 || m_nMinute != 0 || m_dSecond != 0)
	{
		*szTmp++ = _T('T');
		if (m_nHour != 0)
			szTmp += _stprintf(szTmp, _T("%iH"), abs(m_nHour));
		if (m_nMinute != 0)
			szTmp += _stprintf(szTmp, _T("%iM"), abs(m_nMinute));
		if (m_dSecond != 0)
		{
			double d = m_dSecond < 0 ? m_dSecond * -1 : m_dSecond;
			if (m_dSecond - floor(m_dSecond) == 0)
			{
				szTmp += _stprintf(szTmp, _T("%01.f"), d);
			}
			else
			{
				szTmp += _stprintf(szTmp, _T("%.9f"), d);
				while (*(szTmp-1) == _T('0'))
					*--szTmp = 0;
			}
			*szTmp++ = _T('S');
		}
	}
	*szTmp = 0;

	return szResult;
}


bool CSchemaDuration::ToBool() const
{
	return !m_bIsEmpty;
}

CSchemaDuration::operator CSchemaDuration() const
{
	return *this;
}

CSchemaDuration::operator CSchemaDate() const
{
	ThrowIncompatibleTypesError();
}

CSchemaDuration::operator CSchemaDateTime() const
{
	ThrowIncompatibleTypesError();
}

CSchemaDuration::operator CSchemaDay() const
{
	ThrowIncompatibleTypesError();
}

CSchemaDuration::operator CSchemaMonth() const
{
	ThrowIncompatibleTypesError();
}

CSchemaDuration::operator CSchemaMonthDay() const
{
	ThrowIncompatibleTypesError();
}

CSchemaDuration::operator CSchemaTime() const
{
	CSchemaTime	r;
	if( m_bIsEmpty )
		return r;

	if( m_nDay>0 || m_nMonth>0 || m_nYear>0 || !m_bPositive )
		ThrowValuesNotConvertableError();
	r.SetHour( m_nHour );
	r.SetMinute( m_nMinute );
	r.SetSecond( m_dSecond );
	return r;
}

CSchemaDuration::operator CSchemaYear() const
{
	ThrowIncompatibleTypesError();
}

CSchemaDuration::operator CSchemaYearMonth() const
{
	ThrowIncompatibleTypesError();
}


bool CSchemaDuration::IsPositive() const
{
	return m_bIsEmpty ? false : m_bPositive;
}


int CSchemaDuration::GetYear() const
{
	return m_nYear;
}


int CSchemaDuration::GetMonth() const
{
	return m_nMonth;
}


int CSchemaDuration::GetDay() const
{
	return m_nDay;
}


int CSchemaDuration::GetHour() const
{
	return m_nHour;
}


int CSchemaDuration::GetMinute() const
{
	return m_nMinute;
}


double CSchemaDuration::GetSecond() const
{
	return m_dSecond;
}


void CSchemaDuration::SetPositive(bool bPositive)
{
	m_bIsEmpty = false;
	m_bPositive = bPositive;
}


void CSchemaDuration::SetYear(int nYear)
{
	m_bIsEmpty = false;
	m_nYear = nYear;
}


void CSchemaDuration::SetMonth(int nMonth)
{
	m_bIsEmpty = false;
	m_nMonth = nMonth;
}


void CSchemaDuration::SetDay(int nDay)
{
	m_bIsEmpty = false;
	m_nDay = nDay;
}


void CSchemaDuration::SetHour(int nHour)
{
	m_bIsEmpty = false;
	m_nHour = nHour;
}


void CSchemaDuration::SetMinute(int nMinute)
{
	m_bIsEmpty = false;
	m_nMinute = nMinute;
}


void CSchemaDuration::SetSecond(double dSecond)
{
	m_bIsEmpty = false;
	m_dSecond = dSecond;
}


void CSchemaDuration::Parse(const TCHAR* szValue)
{
	const TCHAR* szTmp = szValue;
	bool bTime = false;
	int nTmp;

	Empty();
	if( !(m_bPositive = *szTmp != _T('-')) )
		szTmp++;
	int nSign = m_bPositive ? 1 : -1;
	ParseChar(&szTmp, _T('P'));

	while (*szTmp)
	{
		if (*szTmp == _T('T'))
		{
			if (bTime)
				ThrowFormatError();
			szTmp++;
			bTime = true;
		}
		nTmp = ParseInt(&szTmp);
		if (!bTime)
		{
			switch (*szTmp)
			{
			case _T('Y'):	m_nYear  = nTmp * nSign; break;
			case _T('M'):	m_nMonth = nTmp * nSign; break;
			case _T('D'):	m_nDay   = nTmp * nSign; break;
			default:		ThrowFormatError();
			}
		}
		else
		{
			switch (*szTmp)
			{
			case _T('H'):	m_nHour   = nTmp * nSign; break;
			case _T('M'):	m_nMinute = nTmp * nSign; break;
			case _T('S'):	m_dSecond = nTmp * nSign; break;
			case _T('.'):	m_dSecond = (nTmp + ParseDouble(&szTmp)) * nSign;
							if (*szTmp != _T('S'))
								ThrowFormatError();
							break;
			default:		ThrowFormatError();
			}
		}
		szTmp++;
	}
	m_bIsEmpty = false;
}

CSchemaType& CSchemaDuration::Assign(const CSchemaType& rObject)
{
	Empty();
	const CSchemaTypeCalendar* pCalendarType = dynamic_cast<const CSchemaTypeCalendar*>(&rObject);
	if( pCalendarType == NULL)
		ThrowIncompatibleTypesError();

	m_bIsEmpty = rObject.IsEmpty();
//	CSchemaDuration& rOther = (CSchemaDuration)(*pCalendarType);	
	CSchemaDuration& rOther = (CSchemaDuration&)(*pCalendarType);	
	m_bPositive = rOther.m_bPositive;
	m_nYear = rOther.m_nYear;
	m_nMonth = rOther.m_nMonth;
	m_nDay = rOther.m_nDay;
	m_nHour = rOther.m_nHour;
	m_nMinute = rOther.m_nMinute;
	m_dSecond = rOther.m_dSecond;
	return *this;
}

void CSchemaDuration::Empty()
{
	m_bIsEmpty = true;
	m_bPositive = false;
	m_nYear = 0;
	m_nMonth = 0;
	m_nDay = 0;
	m_nHour = 0;
	m_nMinute = 0;
	m_dSecond = 0;
}

CSchemaDuration operator+(const CSchemaDuration& dur1, const CSchemaDuration& dur2)
{
	return CSchemaDuration(
			!(dur1.m_bPositive	^ dur2.m_bPositive),
			dur1.m_nYear		+ dur2.m_nYear,
			dur1.m_nMonth		+ dur2.m_nMonth,
			dur1.m_nDay			+ dur2.m_nDay,
			dur1.m_nHour		+ dur2.m_nHour,
			dur1.m_nMinute		+ dur2.m_nMinute,
			dur1.m_dSecond		+ dur2.m_dSecond
			);
}

double	CSchemaDuration::ApproximatedNormalizedSeconds() const
{
	return ( m_bPositive ? 1 : -1 ) * 
		( ((((m_nYear*12+m_nMonth)*31+m_nDay)*24+m_nHour)*60+m_nMinute)*60+m_dSecond );
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaDateTimeBase
//
////////////////////////////////////////////////////////////////////////


CSchemaDateTimeBase::CSchemaDateTimeBase()
{
}


CSchemaDateTimeBase::CSchemaDateTimeBase(bool bUTC)
{
	m_nTZMode	= bUTC ? TZ_UTC : TZ_Missing;
	m_nOffset	= 0;
}


CSchemaDateTimeBase::CSchemaDateTimeBase(int nOffset)
{
	m_nTZMode		= TZ_Offset;
	m_nOffset		= nOffset;
}


bool CSchemaDateTimeBase::HasTimezone() const
{
	return m_nTZMode != TZ_Missing;
}


int CSchemaDateTimeBase::GetTimezoneMode() const
{
	return m_nTZMode;
}


int CSchemaDateTimeBase::GetOffset() const
{
	return m_nOffset;
}


void CSchemaDateTimeBase::SetTimezoneMode(int nTZMode)
{
	m_nTZMode = nTZMode;
	if (m_nTZMode == TZ_Missing || m_nTZMode == TZ_UTC)
		m_nOffset = 0;
}


void CSchemaDateTimeBase::SetOffset(int nOffset)
{
	m_nTZMode = TZ_Offset;
	m_nOffset = nOffset;
}


int CSchemaDateTimeBase::WriteTime(TCHAR* szTarget, int nHour, int nMinute, double dSecond)
{
	if (dSecond - floor(dSecond) == 0)
	{
		return _stprintf(szTarget, _T("%02i:%02i:%02.f"), nHour, nMinute, floor(dSecond));
	}
	else
	{
		TCHAR* szLast = szTarget + _stprintf(szTarget, _T("%02i:%02i:%02.9f"), nHour, nMinute, dSecond);

		while (*--szLast == _T('0'))
			*szLast = 0;

		return szLast - szTarget;
	}
}


void CSchemaDateTimeBase::ParseTZ(const TCHAR* szValue)
{
	const TCHAR* szTmp = szValue;

	if (*szTmp == 0)
	{
		m_nTZMode = TZ_Missing;
		m_nOffset = 0;
	}
	else if (*szTmp == _T('Z'))
	{
		m_nTZMode = TZ_UTC;
		m_nOffset = 0;
		if (*++szTmp)
			ThrowFormatError();
	}
	else
	{
		m_nTZMode = TZ_Offset;
		int nOffsetHour = ParseInt(&szTmp);
		ParseChar(&szTmp, _T(':'));
		int nOffsetMinute = ParseInt(&szTmp);
		if (nOffsetHour < 0)
			m_nOffset = nOffsetHour * 60 - nOffsetMinute;
		else
			m_nOffset = nOffsetHour * 60 + nOffsetMinute;
		if (*szTmp)
			ThrowFormatError();
	}
}


void CSchemaDateTimeBase::WriteTZ(TCHAR* szTarget) const
{
	switch (m_nTZMode)
	{
	case TZ_UTC:
		_tcscat(szTarget, _T("Z"));
		break;
	
	case TZ_Offset:
		_stprintf(szTarget + _tcslen(szTarget), _T("%c%02i:%02i"),
				m_nOffset < 0 ? _T('-') : _T('+'),
				abs(m_nOffset / 60),
				abs(m_nOffset % 60)
				);
		break;
	}
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaDate
//
////////////////////////////////////////////////////////////////////////


CSchemaDate::CSchemaDate()
: CSchemaDateTimeBase( CSchemaType::k_Date )
{
	Empty();
}


CSchemaDate::CSchemaDate(int nYear, int nMonth, int nDay, bool bUTC) 
: CSchemaDateTimeBase(bUTC)
{
	m_bIsEmpty = false;
	m_nYear		= nYear;
	m_nMonth	= nMonth;
	m_nDay		= nDay;
}


CSchemaDate::CSchemaDate(int nYear, int nMonth, int nDay, int nOffset) 
: CSchemaDateTimeBase(nOffset)
{
	m_bIsEmpty = false;
	m_nYear		= nYear;
	m_nMonth	= nMonth;
	m_nDay		= nDay;
}


CSchemaDate::CSchemaDate(const TCHAR* szValue) 
{
	Parse(szValue);
}


CSchemaDate::CSchemaDate(const CSchemaType& rObject) 
: CSchemaDateTimeBase( CSchemaType::k_Date )
{
	*this = rObject;
}


CSchemaDate::operator tstring() const
{
	if( m_bIsEmpty )
		return _T("");
	TCHAR szTmp[32];
	int nPos = _stprintf(szTmp, _T("%04i-%02i-%02i"), m_nYear, m_nMonth, m_nDay);
	WriteTZ(szTmp + nPos);
	return szTmp;
}


bool CSchemaDate::ToBool() const
{
	return !m_bIsEmpty;
}

CSchemaDate::operator CSchemaDate() const
{
	return *this;
}

CSchemaDate::operator CSchemaDateTime() const
{
	CSchemaDateTime r;
	if( m_bIsEmpty )
		return r;

	r.SetYear( m_nYear );
	r.SetMonth( m_nMonth );
	r.SetDay( m_nDay );
	r.SetHour( 0 );
	r.SetMinute( 0 );
	r.SetSecond( 0.0 );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}

CSchemaDate::operator CSchemaDay() const
{
	CSchemaDay r;
	if( m_bIsEmpty )
		return r;

	r.SetDay( m_nDay );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}

CSchemaDate::operator CSchemaDuration() const
{
	ThrowIncompatibleTypesError();
}

CSchemaDate::operator CSchemaMonth() const
{
	CSchemaMonth r;
	if( m_bIsEmpty )
		return r;

	r.SetMonth( m_nMonth );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}

CSchemaDate::operator CSchemaMonthDay() const
{
	CSchemaMonthDay r;
	if( m_bIsEmpty )
		return r;

	r.SetMonth( m_nMonth );
	r.SetDay( m_nDay );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}

CSchemaDate::operator CSchemaTime() const
{
	ThrowIncompatibleTypesError();
}

CSchemaDate::operator CSchemaYear() const
{
	CSchemaYear r;
	if( m_bIsEmpty )
		return r;

	r.SetYear( m_nYear );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}

CSchemaDate::operator CSchemaYearMonth() const
{
	CSchemaYearMonth r;
	if( m_bIsEmpty )
		return r;

	r.SetYear( m_nYear );
	r.SetMonth( m_nMonth );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}


int CSchemaDate::GetYear() const
{
	return m_nYear;
}


int CSchemaDate::GetMonth() const
{
	return m_nMonth;
}


int CSchemaDate::GetDay() const
{
	return m_nDay;
}


void CSchemaDate::SetYear(int nYear)
{
	m_bIsEmpty = false;
	m_nYear = nYear;
}


void CSchemaDate::SetMonth(int nMonth)
{
	m_bIsEmpty = false;
	m_nMonth = nMonth;
}


void CSchemaDate::SetDay(int nDay)
{
	m_bIsEmpty = false;
	m_nDay = nDay;
}


void CSchemaDate::Parse(const TCHAR* szValue)
{
	const TCHAR* szTmp = szValue;

	Empty();

	m_nYear = ParseInt(&szTmp);
	ParseChar(&szTmp, _T('-'));
	m_nMonth = ParseInt(&szTmp);
	ParseChar(&szTmp, _T('-'));
	m_nDay = ParseInt(&szTmp);
	ParseTZ(szTmp);

	m_bIsEmpty = false;
}


CSchemaType& CSchemaDate::Assign(const CSchemaType& rObject)
{
	Empty();
	const CSchemaTypeCalendar* pCalendarType = dynamic_cast<const CSchemaTypeCalendar*>(&rObject);
	if( pCalendarType == NULL )
		ThrowIncompatibleTypesError();
	m_bIsEmpty = rObject.IsEmpty();
//	CSchemaDate& rOther = (CSchemaDate)(*pCalendarType);	
	CSchemaDate& rOther = (CSchemaDate&)(*pCalendarType);	
	m_nYear = rOther.m_nYear;
	m_nMonth = rOther.m_nMonth;
	m_nDay = rOther.m_nDay;
	SetTimezoneMode( rOther.GetTimezoneMode() );
	if( rOther.GetTimezoneMode() == TZ_Offset )
		SetOffset( rOther.GetOffset() );
	return *this;
}


void CSchemaDate::Empty()
{
	m_bIsEmpty = true;
	time_t long_time;
	time( &long_time ); 
	struct tm *newtime = localtime( &long_time ); 

	m_nYear = newtime->tm_year + 1900;
	m_nMonth = newtime->tm_mon;
	m_nDay = newtime->tm_sec;
}


bool operator==(const CSchemaDate& t1, const CSchemaDate& t2)
{
	if (t1.HasTimezone() == t2.HasTimezone())
		return t1.m_nYear == t2.m_nYear
			&& t1.m_nMonth == t2.m_nMonth
			&& t1.m_nDay == t2.m_nDay;
	else
		return false;
}


bool operator<(const CSchemaDate& t1, const CSchemaDate& t2)
{
	if (t1.HasTimezone() == t2.HasTimezone())
		return t1.m_nYear < t2.m_nYear
			|| (t1.m_nYear == t2.m_nYear && t1.m_nMonth < t2.m_nMonth)
			|| (t1.m_nYear == t2.m_nYear && t1.m_nMonth == t2.m_nMonth && t1.m_nDay < t2.m_nDay);
	else
		return false;
}


bool operator!=(const CSchemaDate& t1, const CSchemaDate& t2)
{
	return !(t1 == t2);
}


bool operator<=(const CSchemaDate& t1, const CSchemaDate& t2)
{
	return t1 < t2 || t1 == t2;
}


bool operator>(const CSchemaDate& t1, const CSchemaDate& t2)
{
	return t2 < t1;
}


bool operator>=(const CSchemaDate& t1, const CSchemaDate& t2)
{
	return t2 < t1 || t1 == t2;
}


CSchemaDate operator+(const CSchemaDate& t, const CSchemaDuration& dur)
{
	CSchemaDate r	= t;
	int nHour		= 0;
	int nMinute		= 0;
	double dSecond	= 0;

	DateTimeAddDuration(r.m_nYear, r.m_nMonth, r.m_nDay, nHour, nMinute, dSecond, dur);

	return r;
}


CSchemaDuration operator-(const CSchemaDate& t1, const CSchemaDate& t2)
{
	CSchemaDuration tmp(false, -t2.m_nYear, -t2.m_nMonth, -t2.m_nDay, 0, 0, 0);
	CSchemaDate t = t1 + tmp;
	return CSchemaDuration(true, t.m_nYear, t.m_nMonth, t.m_nDay, 0, 0, 0);
}


long CSchemaDate::ApproximatedNormalizedDays() const
{
	return (m_nYear*12+m_nMonth)*31 + m_nDay;
}

////////////////////////////////////////////////////////////////////////
//
//  CSchemaTime
//
////////////////////////////////////////////////////////////////////////


CSchemaTime::CSchemaTime()
{
	Empty();
}


CSchemaTime::CSchemaTime(int nHour, int nMinute, double dSecond, bool bUTC) 
: CSchemaDateTimeBase(bUTC)
{
	m_bIsEmpty = false;
	m_nHour		= nHour;
	m_nMinute	= nMinute;
	m_dSecond	= dSecond;
}


CSchemaTime::CSchemaTime(int nHour, int nMinute, double dSecond, int nOffset) 
: CSchemaDateTimeBase(nOffset)
{
	m_bIsEmpty = false;
	m_nHour		= nHour;
	m_nMinute	= nMinute;
	m_dSecond	= dSecond;
}


CSchemaTime::CSchemaTime(const TCHAR* szValue) 
{
	Parse(szValue);
}


CSchemaTime::CSchemaTime(const CSchemaType& rObject) 
{
	*this = rObject;
}


CSchemaTime::operator tstring() const
{
	if( m_bIsEmpty )
		return _T("");
	TCHAR szTmp[64];
	int nPos = WriteTime(szTmp, m_nHour, m_nMinute, m_dSecond);
	WriteTZ(szTmp + nPos);
	return szTmp;
}


bool CSchemaTime::ToBool() const
{
	return !m_bIsEmpty;
}


CSchemaTime::operator CSchemaDate() const
{
	ThrowIncompatibleTypesError();
}

CSchemaTime::operator CSchemaDateTime() const
{
	ThrowIncompatibleTypesError();
}

CSchemaTime::operator CSchemaDay() const
{
	ThrowIncompatibleTypesError();
}

CSchemaTime::operator CSchemaDuration() const
{
	CSchemaDuration r;
	if( m_bIsEmpty )
		return r;

	r.SetHour( m_nHour );
	r.SetMinute( m_nMinute );
	r.SetSecond( m_dSecond );
	return r;
}

CSchemaTime::operator CSchemaMonth() const
{
	ThrowIncompatibleTypesError();
}

CSchemaTime::operator CSchemaMonthDay() const
{
	ThrowIncompatibleTypesError();
}

CSchemaTime::operator CSchemaTime() const
{
	return *this;
}

CSchemaTime::operator CSchemaYear() const
{
	ThrowIncompatibleTypesError();
}

CSchemaTime::operator CSchemaYearMonth() const
{
	ThrowIncompatibleTypesError();
}


int CSchemaTime::GetHour() const
{
	return m_nHour;
}


int CSchemaTime::GetMinute() const
{
	return m_nMinute;
}



double CSchemaTime::GetSecond() const
{
	return m_dSecond;
}


void CSchemaTime::SetHour(int nHour)
{
	m_nHour = nHour;
	m_bIsEmpty = false;
}


void CSchemaTime::SetMinute(int nMinute)
{
	m_nMinute = nMinute;
	m_bIsEmpty = false;
}


void CSchemaTime::SetSecond(double dSecond)
{
	m_dSecond = dSecond;
	m_bIsEmpty = false;
}


void CSchemaTime::Parse(const TCHAR* szValue)
{
	const TCHAR* szTmp = szValue;

	Empty();

	m_nHour = ParseInt(&szTmp);
	ParseChar(&szTmp, _T(':'));
	m_nMinute = ParseInt(&szTmp);
	ParseChar(&szTmp, _T(':'));
	m_dSecond = ParseDouble(&szTmp);
	ParseTZ(szTmp);

	m_bIsEmpty = false;
}


CSchemaType& CSchemaTime::Assign(const CSchemaType& rObject)
{
	Empty();
	const CSchemaTypeCalendar* pCalendarType = dynamic_cast<const CSchemaTypeCalendar*>(&rObject);
	if( pCalendarType == NULL )
		ThrowIncompatibleTypesError();

	m_bIsEmpty = rObject.IsEmpty();
//	CSchemaTime& rOther = (CSchemaTime)(*pCalendarType);
	CSchemaTime& rOther = (CSchemaTime&)(*pCalendarType);
	m_nHour = rOther.m_nHour;
	m_nMinute = rOther.m_nMinute;
	m_dSecond = rOther.m_dSecond;
	SetTimezoneMode( rOther.GetTimezoneMode() );
	if( rOther.GetTimezoneMode() == TZ_Offset )
		SetOffset( rOther.GetOffset() );
	return *this;
}


void CSchemaTime::Empty()
{
	m_bIsEmpty = true;
	m_nHour = 0;
	m_nMinute = 0;
	m_dSecond = 0.0;
}


double CSchemaTime::NormalizedSeconds() const
{
	return m_nHour * 3600 + m_nMinute * 60 + m_dSecond - m_nOffset * 60;
}


bool operator==(const CSchemaTime& t1, const CSchemaTime& t2)
{
	if (t1.HasTimezone() == t2.HasTimezone())
		return t1.NormalizedSeconds() == t2.NormalizedSeconds();
	else
		return false;
}


bool operator<(const CSchemaTime& t1, const CSchemaTime& t2)
{
	if (t1.HasTimezone() == t2.HasTimezone())
		return t1.NormalizedSeconds() < t2.NormalizedSeconds();

	if (t1.HasTimezone())
		return t1.NormalizedSeconds() < t2.NormalizedSeconds() - 50400;
	else
		return t1.NormalizedSeconds() + 50400 < t2.NormalizedSeconds();
}


bool operator!=(const CSchemaTime& t1, const CSchemaTime& t2)
{
	return !(t1 == t2);
}


bool operator<=(const CSchemaTime& t1, const CSchemaTime& t2)
{
	return t1 < t2 || t1 == t2;
}


bool operator>(const CSchemaTime& t1, const CSchemaTime& t2)
{
	return t2 < t1;
}


bool operator>=(const CSchemaTime& t1, const CSchemaTime& t2)
{
	return t2 < t1 || t1 == t2;
}


CSchemaTime operator+(const CSchemaTime& t, const CSchemaDuration& dur)
{
	CSchemaTime r	= t;
	int nYear		= 1;
	int nMonth		= 1;
	int nDay		= 1;

	DateTimeAddDuration(nYear, nMonth, nDay, r.m_nHour, r.m_nMinute, r.m_dSecond, dur);

	return r;
}


CSchemaDuration operator-(const CSchemaTime& t1, const CSchemaTime& t2)
{
	CSchemaDuration tmp(false, 0, 0, 0, -t2.m_nHour, -t2.m_nMinute, -t2.m_dSecond);
	CSchemaTime t = t1 + tmp;
	return CSchemaDuration(true, 0, 0, 0, t.m_nHour, t.m_nMinute, t.m_dSecond);
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaDateTime
//
////////////////////////////////////////////////////////////////////////


CSchemaDateTime::CSchemaDateTime()
{
	Empty();
}


CSchemaDateTime::CSchemaDateTime(int nYear, int nMonth, int nDay, int nHour, int nMinute, double dSecond, bool bUTC) 
: CSchemaDateTimeBase(bUTC)
{
	m_bIsEmpty = false;
	m_nYear		= nYear;
	m_nMonth	= nMonth;
	m_nDay		= nDay;
	m_nHour		= nHour;
	m_nMinute	= nMinute;
	m_dSecond	= dSecond;
}


CSchemaDateTime::CSchemaDateTime(int nYear, int nMonth, int nDay, int nHour, int nMinute, double dSecond, int nOffset) 
: CSchemaDateTimeBase(nOffset)
{
	m_bIsEmpty = false;
	m_nYear		= nYear;
	m_nMonth	= nMonth;
	m_nDay		= nDay;
	m_nHour		= nHour;
	m_nMinute	= nMinute;
	m_dSecond	= dSecond;
}


CSchemaDateTime::CSchemaDateTime(const TCHAR* szValue) 
{
	Parse(szValue);
}


CSchemaDateTime::CSchemaDateTime(const CSchemaType& rObject) 
{
	*this = rObject;
}


CSchemaDateTime::operator tstring() const
{
	if( m_bIsEmpty )
		return _T("");
	TCHAR szTmp[64];
	int nPos = _stprintf(szTmp, _T("%04i-%02i-%02iT"), m_nYear, m_nMonth, m_nDay);
	nPos += WriteTime(szTmp + nPos, m_nHour, m_nMinute, m_dSecond);
	WriteTZ(szTmp + nPos);
	return szTmp;
}


bool CSchemaDateTime::ToBool() const
{
	return !m_bIsEmpty;
}


CSchemaDateTime::operator CSchemaDate() const
{
	CSchemaDate r;
	if( m_bIsEmpty )
		return r;

	r.SetYear( m_nYear );
	r.SetMonth( m_nMonth );
	r.SetDay( m_nDay );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}

CSchemaDateTime::operator CSchemaDateTime() const
{
	return *this;
}

CSchemaDateTime::operator CSchemaDay() const
{
	CSchemaDay r;
	if( m_bIsEmpty )
		return r;

	r.SetDay( m_nDay );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}

CSchemaDateTime::operator CSchemaDuration() const
{
	ThrowIncompatibleTypesError();
}

CSchemaDateTime::operator CSchemaMonth() const
{
	CSchemaMonth r;
	if( m_bIsEmpty )
		return r;

	r.SetMonth( m_nMonth );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}

CSchemaDateTime::operator CSchemaMonthDay() const
{
	CSchemaMonthDay r;
	if( m_bIsEmpty )
		return r;

	r.SetMonth( m_nMonth );
	r.SetDay( m_nDay );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}

CSchemaDateTime::operator CSchemaTime() const
{
	CSchemaTime r;
	if( m_bIsEmpty )
		return r;

	r.SetHour( m_nHour );
	r.SetMinute( m_nMinute );
	r.SetSecond( m_dSecond );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}

CSchemaDateTime::operator CSchemaYear() const
{
	CSchemaYear r;
	if( m_bIsEmpty )
		return r;

	r.SetYear( m_nYear );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}

CSchemaDateTime::operator CSchemaYearMonth() const
{
	CSchemaYearMonth r;
	if( m_bIsEmpty )
		return r;

	r.SetYear( m_nYear );
	r.SetMonth( m_nMonth );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}


int CSchemaDateTime::GetYear() const
{
	return m_nYear;
}


int CSchemaDateTime::GetMonth() const
{
	return m_nMonth;
}


int CSchemaDateTime::GetDay() const
{
	return m_nDay;
}


int CSchemaDateTime::GetHour() const
{
	return m_nHour;
}


int CSchemaDateTime::GetMinute() const
{
	return m_nMinute;
}


double CSchemaDateTime::GetSecond() const
{
	return m_dSecond;
}


void CSchemaDateTime::SetYear(int nYear)
{
	m_bIsEmpty = false;
	m_nYear = nYear;
}


void CSchemaDateTime::SetMonth(int nMonth)
{
	m_bIsEmpty = false;
	m_nMonth = nMonth;
}


void CSchemaDateTime::SetDay(int nDay)
{
	m_bIsEmpty = false;
	m_nDay = nDay;
}


void CSchemaDateTime::SetHour(int nHour)
{
	m_bIsEmpty = false;
	m_nHour = nHour;
}


void CSchemaDateTime::SetMinute(int nMinute)
{
	m_bIsEmpty = false;
	m_nMinute = nMinute;
}


void CSchemaDateTime::SetSecond(double dSecond)
{
	m_bIsEmpty = false;
	m_dSecond = dSecond;
}


void CSchemaDateTime::Parse(const TCHAR* szValue)
{
	const TCHAR* szTmp = szValue;

	Empty();

	m_nYear = ParseInt(&szTmp);
	ParseChar(&szTmp, _T('-'));
	m_nMonth = ParseInt(&szTmp);
	ParseChar(&szTmp, _T('-'));
	m_nDay = ParseInt(&szTmp);
	ParseChar(&szTmp, _T('T'));
	m_nHour = ParseInt(&szTmp);
	ParseChar(&szTmp, _T(':'));
	m_nMinute = ParseInt(&szTmp);
	ParseChar(&szTmp, _T(':'));
	m_dSecond = ParseDouble(&szTmp);
	ParseTZ(szTmp);

	m_bIsEmpty = false;
}


CSchemaType& CSchemaDateTime::Assign(const CSchemaType& rObject)
{
	Empty();
	const CSchemaTypeCalendar* pCalendarType = dynamic_cast<const CSchemaTypeCalendar*>(&rObject);
	if( pCalendarType == NULL )
		ThrowIncompatibleTypesError();

	m_bIsEmpty = rObject.IsEmpty();
//	CSchemaDateTime& rOther = (CSchemaDateTime)(*pCalendarType);	
	CSchemaDateTime& rOther = (CSchemaDateTime&)(*pCalendarType);	
	m_nYear = rOther.m_nYear;
	m_nMonth = rOther.m_nMonth;
	m_nDay = rOther.m_nDay;
	m_nHour = rOther.m_nHour;
	m_nMinute = rOther.m_nMinute;
	m_dSecond = rOther.m_dSecond;
	SetTimezoneMode( rOther.GetTimezoneMode() );
	if( rOther.GetTimezoneMode() == TZ_Offset )
		SetOffset( rOther.GetOffset() );
	return *this;
}


void CSchemaDateTime::Empty()
{
	m_bIsEmpty = true;
	time_t long_time;
	time( &long_time ); 
	struct tm *newtime = localtime( &long_time ); 
	m_nYear = newtime->tm_year + 1900;
	m_nMonth = newtime->tm_mon;
	m_nDay = newtime->tm_mday;
	m_nHour = newtime->tm_hour;
	m_nMinute = newtime->tm_min;
	m_dSecond = newtime->tm_sec;
}


bool operator==(const CSchemaDateTime& t1, const CSchemaDateTime& t2)
{
	if (t1.HasTimezone() == t2.HasTimezone())
		return t1.m_nYear == t2.m_nYear
			&& t1.m_nMonth == t2.m_nMonth
			&& t1.m_nDay == t2.m_nDay
			&& t1.m_nHour == t2.m_nHour
			&& t1.m_nMinute == t2.m_nMinute
			&& t1.m_dSecond == t2.m_dSecond;
	else
		return false;
}


bool operator<(const CSchemaDateTime& t1, const CSchemaDateTime& t2)
{
	CSchemaDateTime x1 = t1;
	CSchemaDateTime x2 = t2;

	if (t1.HasTimezone() != t2.HasTimezone())
	{
		if (t1.HasTimezone())
		{
			CSchemaDuration dur(false, 0, 0, 0, -14, 0, 0);
			DateTimeAddDuration(x2.m_nYear, x2.m_nMonth, x2.m_nDay, x2.m_nHour, x2.m_nMinute, x2.m_dSecond, dur);
		}
		else
		{
			CSchemaDuration dur(true, 0, 0, 0, 14, 0, 0);
			DateTimeAddDuration(x1.m_nYear, x2.m_nMonth, x2.m_nDay, x2.m_nHour, x2.m_nMinute, x2.m_dSecond, dur);
		}
	}

	if (x1.m_nYear		< x2.m_nYear)	return true;
	if (x1.m_nYear		> x2.m_nYear)	return false;
	if (x1.m_nMonth		< x2.m_nMonth)	return true;
	if (x1.m_nMonth		> x2.m_nMonth)	return false;
	if (x1.m_nDay		< x2.m_nDay)	return true;
	if (x1.m_nDay		> x2.m_nDay)	return false;
	if (x1.m_nHour		< x2.m_nHour)	return true;
	if (x1.m_nHour		> x2.m_nHour)	return false;
	if (x1.m_nMinute	< x2.m_nMinute)	return true;
	if (x1.m_nMinute	> x2.m_nMinute)	return false;
	if (x1.m_dSecond	< x2.m_dSecond)	return true;
	return false;
}


bool operator!=(const CSchemaDateTime& t1, const CSchemaDateTime& t2)
{
	return !(t1 == t2);
}


bool operator<=(const CSchemaDateTime& t1, const CSchemaDateTime& t2)
{
	return t1 < t2 || t1 == t2;
}


bool operator>(const CSchemaDateTime& t1, const CSchemaDateTime& t2)
{
	return t2 < t1;
}


bool operator>=(const CSchemaDateTime& t1, const CSchemaDateTime& t2)
{
	return t2 < t1 || t1 == t2;
}


CSchemaDateTime operator+(const CSchemaDateTime& t, const CSchemaDuration& dur)
{
	CSchemaDateTime r = t;
	DateTimeAddDuration(r.m_nYear, r.m_nMonth, r.m_nDay, r.m_nHour, r.m_nMinute, r.m_dSecond, dur);
	return r;
}


CSchemaDuration operator-(const CSchemaDateTime& t1, const CSchemaDateTime& t2)
{
	CSchemaDuration tmp(false, -t2.m_nYear, -t2.m_nMonth, -t2.m_nDay, -t2.m_nHour, -t2.m_nMinute, -t2.m_dSecond);
	CSchemaDateTime t = t1 + tmp;
	return CSchemaDuration(true, t.m_nYear, t.m_nMonth, t.m_nDay, t.m_nHour, t.m_nMinute, t.m_dSecond);
}


double	CSchemaDateTime::ApproximatedNormalizedSeconds() const
{
	return ((((m_nYear*12+m_nMonth)*31+m_nDay)*24+m_nHour)*60+m_nMinute)*60+m_dSecond;
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaYear
//
////////////////////////////////////////////////////////////////////////


CSchemaYear::CSchemaYear()
: CSchemaDateTimeBase( CSchemaType::k_Year )
{
	Empty();
}


CSchemaYear::CSchemaYear(int nYear, bool bUTC) 
: CSchemaDateTimeBase(bUTC)
{
	m_bIsEmpty = false;
	m_nYear = nYear;
}


CSchemaYear::CSchemaYear(int nYear, int nOffset) 
: CSchemaDateTimeBase(nOffset)
{
	m_bIsEmpty = false;
	m_nYear = nYear;
}


CSchemaYear::CSchemaYear(const TCHAR* szValue) 
{
	Parse(szValue);
}


CSchemaYear::CSchemaYear(const CSchemaType& rObject) 
{
	*this = rObject;
}


CSchemaYear::operator tstring() const
{
	if( m_bIsEmpty )
		return _T("");
	TCHAR szTmp[32];
	int nPos = _stprintf(szTmp, _T("%04i"), m_nYear);
	WriteTZ(szTmp + nPos);
	return szTmp;
}


bool CSchemaYear::ToBool() const
{
	return !m_bIsEmpty;
}


CSchemaYear::operator CSchemaDate() const
{
	ThrowIncompatibleTypesError();
}

CSchemaYear::operator CSchemaDateTime() const
{
	ThrowIncompatibleTypesError();
}

CSchemaYear::operator CSchemaDay() const
{
	ThrowIncompatibleTypesError();
}

CSchemaYear::operator CSchemaDuration() const
{
	ThrowIncompatibleTypesError();
}

CSchemaYear::operator CSchemaMonth() const
{
	ThrowIncompatibleTypesError();
}

CSchemaYear::operator CSchemaMonthDay() const
{
	ThrowIncompatibleTypesError();
}

CSchemaYear::operator CSchemaTime() const
{
	ThrowIncompatibleTypesError();
}

CSchemaYear::operator CSchemaYear() const
{
	return *this;
}

CSchemaYear::operator CSchemaYearMonth() const
{
	ThrowIncompatibleTypesError();
}



int CSchemaYear::GetYear() const
{
	return m_nYear;
}


void CSchemaYear::SetYear(int nYear)
{
	m_bIsEmpty = false;
	m_nYear = nYear;
}


void CSchemaYear::Parse(const TCHAR* szValue)
{
	const TCHAR* szTmp = szValue;

	Empty();

	m_nYear = ParseInt(&szTmp);
	ParseTZ(szTmp);

	m_bIsEmpty = false;
}


CSchemaType& CSchemaYear::Assign(const CSchemaType& rObject)
{
	Empty();
	const CSchemaTypeCalendar* pCalendarType = dynamic_cast<const CSchemaTypeCalendar*>(&rObject);
	if( pCalendarType == NULL )
		ThrowIncompatibleTypesError();

	m_bIsEmpty = rObject.IsEmpty();
//	CSchemaYear& rOther = (CSchemaYear)(*pCalendarType);
	CSchemaYear& rOther = (CSchemaYear&)(*pCalendarType);
	m_nYear = rOther.m_nYear;
	SetTimezoneMode( rOther.GetTimezoneMode() );
	if( rOther.GetTimezoneMode() == TZ_Offset )
		SetOffset( rOther.GetOffset() );
	return *this;
}


void CSchemaYear::Empty()
{
	m_bIsEmpty = true;
	m_nYear = 0;
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaYearMonth
//
////////////////////////////////////////////////////////////////////////


CSchemaYearMonth::CSchemaYearMonth()
{
	Empty();
}


CSchemaYearMonth::CSchemaYearMonth(int nYear, int nMonth, bool bUTC) 
: CSchemaDateTimeBase(bUTC)
{
	m_bIsEmpty = false;
	m_nYear		= nYear;
	m_nMonth	= nMonth;
}


CSchemaYearMonth::CSchemaYearMonth(int nYear, int nMonth, int nOffset) 
: CSchemaDateTimeBase(nOffset)
{
	m_bIsEmpty = false;
	m_nYear		= nYear;
	m_nMonth	= nMonth;
}


CSchemaYearMonth::CSchemaYearMonth(const TCHAR* szValue) 
{
	Parse(szValue);
}


CSchemaYearMonth::CSchemaYearMonth(const CSchemaType& rObject) 
{
	*this = rObject;
}


CSchemaYearMonth::operator tstring() const
{
	if( m_bIsEmpty )
		return _T("");
	TCHAR szTmp[32];
	int nPos = _stprintf(szTmp, _T("%04i-%02i"), m_nYear, m_nMonth);
	WriteTZ(szTmp + nPos);
	return szTmp;
}


bool CSchemaYearMonth::ToBool() const
{
	return !m_bIsEmpty;
}


CSchemaYearMonth::operator CSchemaDate() const
{
	ThrowIncompatibleTypesError();
}

CSchemaYearMonth::operator CSchemaDateTime() const
{
	ThrowIncompatibleTypesError();
}

CSchemaYearMonth::operator CSchemaDay() const
{
	ThrowIncompatibleTypesError();
}

CSchemaYearMonth::operator CSchemaDuration() const
{
	ThrowIncompatibleTypesError();
}

CSchemaYearMonth::operator CSchemaMonth() const
{
	CSchemaMonth r;
	if( m_bIsEmpty )
		return r;

	r.SetMonth( m_nMonth );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}

CSchemaYearMonth::operator CSchemaMonthDay() const
{
	ThrowIncompatibleTypesError();
}

CSchemaYearMonth::operator CSchemaTime() const
{
	ThrowIncompatibleTypesError();
}

CSchemaYearMonth::operator CSchemaYear() const
{
	CSchemaYear r;
	if( m_bIsEmpty )
		return r;

	r.SetYear( m_nYear );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}

CSchemaYearMonth::operator CSchemaYearMonth() const
{
	return *this;
}



int CSchemaYearMonth::GetYear() const
{
	return m_nYear;
}


int CSchemaYearMonth::GetMonth() const
{
	return m_nMonth;
}


void CSchemaYearMonth::SetYear(int nYear)
{
	m_bIsEmpty = false;
	m_nYear = nYear;
}


void CSchemaYearMonth::SetMonth(int nMonth)
{
	m_bIsEmpty = false;
	m_nMonth = nMonth;
}


void CSchemaYearMonth::Parse(const TCHAR* szValue)
{
	const TCHAR* szTmp = szValue;

	Empty();

	m_nYear = ParseInt(&szTmp);
	ParseChar(&szTmp, _T('-'));
	m_nMonth = ParseInt(&szTmp);
	ParseTZ(szTmp);

	m_bIsEmpty = false;
}


CSchemaType& CSchemaYearMonth::Assign(const CSchemaType& rObject)
{
	Empty();
	const CSchemaTypeCalendar* pCalendarType = dynamic_cast<const CSchemaTypeCalendar*>(&rObject);
	if( pCalendarType == NULL )
		ThrowIncompatibleTypesError();

	m_bIsEmpty = rObject.IsEmpty();
//	CSchemaYearMonth& rOther = (CSchemaYearMonth)(*pCalendarType);	
	CSchemaYearMonth& rOther = (CSchemaYearMonth&)(*pCalendarType);	
	m_nYear = rOther.m_nYear;
	m_nMonth = rOther.m_nMonth;
	SetTimezoneMode( rOther.GetTimezoneMode() );
	if( rOther.GetTimezoneMode() == TZ_Offset )
		SetOffset( rOther.GetOffset() );
	return *this;
}

void CSchemaYearMonth::Empty()
{
	m_bIsEmpty = true;
	time_t long_time;
	time( &long_time ); 
	struct tm *newtime = localtime( &long_time ); 
	m_nYear = newtime->tm_year + 1900;
	m_nMonth = newtime->tm_mon;
}

long	CSchemaYearMonth::NormalizedMonths() const
{
	return m_nYear*12+m_nMonth;
}

////////////////////////////////////////////////////////////////////////
//
//  CSchemaMonth
//
////////////////////////////////////////////////////////////////////////


CSchemaMonth::CSchemaMonth()
{
	Empty();
}


CSchemaMonth::CSchemaMonth(int nMonth, bool bUTC) 
: CSchemaDateTimeBase(bUTC)
{
	m_bIsEmpty = false;
	m_nMonth = nMonth;
}


CSchemaMonth::CSchemaMonth(int nMonth, int nOffset) 
: CSchemaDateTimeBase(nOffset)
{
	m_bIsEmpty = false;
	m_nMonth = nMonth;
}


CSchemaMonth::CSchemaMonth(const TCHAR* szValue) 
{
	Parse(szValue);
}


CSchemaMonth::CSchemaMonth(const CSchemaType& rObject) 
{
	*this = rObject;
}


CSchemaMonth::operator tstring() const
{
	if( m_bIsEmpty )
		return _T("");
	TCHAR szTmp[32];
	int nPos = _stprintf(szTmp, _T("--%02i--"), m_nMonth);
	WriteTZ(szTmp + nPos);
	return szTmp;
}


bool CSchemaMonth::ToBool() const
{
	return !m_bIsEmpty;
}


CSchemaMonth::operator CSchemaDate() const
{
	ThrowIncompatibleTypesError();
}

CSchemaMonth::operator CSchemaDateTime() const
{
	ThrowIncompatibleTypesError();
}

CSchemaMonth::operator CSchemaDay() const
{
	ThrowIncompatibleTypesError();
}

CSchemaMonth::operator CSchemaDuration() const
{
	ThrowIncompatibleTypesError();
}

CSchemaMonth::operator CSchemaMonth() const
{
	return *this;
}

CSchemaMonth::operator CSchemaMonthDay() const
{
	ThrowIncompatibleTypesError();
}

CSchemaMonth::operator CSchemaTime() const
{
	ThrowIncompatibleTypesError();
}

CSchemaMonth::operator CSchemaYear() const
{
	ThrowIncompatibleTypesError();
}

CSchemaMonth::operator CSchemaYearMonth() const
{
	ThrowIncompatibleTypesError();
}




int CSchemaMonth::GetMonth() const
{
	return m_nMonth;
}


void CSchemaMonth::SetMonth(int nMonth)
{
	m_bIsEmpty = false;
	m_nMonth = nMonth;
}


void CSchemaMonth::Parse(const TCHAR* szValue)
{
	const TCHAR* szTmp = szValue;

	Empty();

	ParseChar(&szTmp, _T('-'));
	ParseChar(&szTmp, _T('-'));
	m_nMonth = ParseInt(&szTmp);
	ParseChar(&szTmp, _T('-'));
	ParseChar(&szTmp, _T('-'));
	ParseTZ(szTmp);

	m_bIsEmpty = false;
}


CSchemaType& CSchemaMonth::Assign(const CSchemaType& rObject)
{
	Empty();
	const CSchemaTypeCalendar* pCalendarType = dynamic_cast<const CSchemaTypeCalendar*>(&rObject);
	if( pCalendarType == NULL )
		ThrowIncompatibleTypesError();

	m_bIsEmpty = rObject.IsEmpty();
//	CSchemaMonth& rOther = (CSchemaMonth)(*pCalendarType);	
	CSchemaMonth& rOther = (CSchemaMonth&)(*pCalendarType);	
	m_nMonth = rOther.m_nMonth;
	SetTimezoneMode( rOther.GetTimezoneMode() );
	if( rOther.GetTimezoneMode() == TZ_Offset )
		SetOffset( rOther.GetOffset() );
	return *this;
}


void CSchemaMonth::Empty()
{
	m_bIsEmpty = true;
	time_t long_time;
	time( &long_time ); 
	struct tm *newtime = localtime( &long_time ); 
	m_nMonth = newtime->tm_mon;
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaMonthDay
//
////////////////////////////////////////////////////////////////////////


CSchemaMonthDay::CSchemaMonthDay()
{
	Empty();
}


CSchemaMonthDay::CSchemaMonthDay(int nMonth, int nDay, bool bUTC) 
: CSchemaDateTimeBase(bUTC)
{
	m_bIsEmpty = false;
	m_nMonth	= nMonth;
	m_nDay		= nDay;
}


CSchemaMonthDay::CSchemaMonthDay(int nMonth, int nDay, int nOffset) 
: CSchemaDateTimeBase(nOffset)
{
	m_bIsEmpty = false;
	m_nMonth	= nMonth;
	m_nDay		= nDay;
}


CSchemaMonthDay::CSchemaMonthDay(const TCHAR* szValue) 
{
	Parse(szValue);
}


CSchemaMonthDay::CSchemaMonthDay(const CSchemaType& rObject) 
{
	*this = rObject;
}


CSchemaMonthDay::operator tstring() const
{
	if( m_bIsEmpty )
		return _T("");
	TCHAR szTmp[32];
	int nPos = _stprintf(szTmp, _T("--%02i-%02i"), m_nMonth, m_nDay);
	WriteTZ(szTmp + nPos);
	return szTmp;
}


bool CSchemaMonthDay::ToBool() const
{
	return !m_bIsEmpty;
}


CSchemaMonthDay::operator CSchemaDate() const
{
	ThrowIncompatibleTypesError();
}

CSchemaMonthDay::operator CSchemaDateTime() const
{
	ThrowIncompatibleTypesError();
}

CSchemaMonthDay::operator CSchemaDay() const
{
	CSchemaDay r;
	if( m_bIsEmpty )
		return r;

	r.SetDay( m_nDay );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}

CSchemaMonthDay::operator CSchemaDuration() const
{
	ThrowIncompatibleTypesError();
}

CSchemaMonthDay::operator CSchemaMonth() const
{
	CSchemaMonth r;
	if( m_bIsEmpty )
		return r;

	r.SetMonth( m_nDay );
	r.SetTimezoneMode( GetTimezoneMode() );
	if( GetTimezoneMode() == TZ_Offset )
		r.SetOffset( GetOffset() );
	return r;
}

CSchemaMonthDay::operator CSchemaMonthDay() const
{
	return *this;
}

CSchemaMonthDay::operator CSchemaTime() const
{
	ThrowIncompatibleTypesError();
}

CSchemaMonthDay::operator CSchemaYear() const
{
	ThrowIncompatibleTypesError();
}

CSchemaMonthDay::operator CSchemaYearMonth() const
{
	ThrowIncompatibleTypesError();
}



int CSchemaMonthDay::GetMonth() const
{
	return m_nMonth;
}


int CSchemaMonthDay::GetDay() const
{
	return m_nDay;
}


void CSchemaMonthDay::SetMonth(int nMonth)
{
	m_bIsEmpty = false;
	m_nMonth = nMonth;
}


void CSchemaMonthDay::SetDay(int nDay)
{
	m_bIsEmpty = false;
	m_nDay = nDay;
}


void CSchemaMonthDay::Parse(const TCHAR* szValue)
{
	const TCHAR* szTmp = szValue;

	Empty();

	ParseChar(&szTmp, _T('-'));
	ParseChar(&szTmp, _T('-'));
	m_nMonth = ParseInt(&szTmp);
	ParseChar(&szTmp, _T('-'));
	m_nDay = ParseInt(&szTmp);
	ParseTZ(szTmp);

	m_bIsEmpty = false;
}


CSchemaType& CSchemaMonthDay::Assign(const CSchemaType& rObject)
{
	Empty();
	const CSchemaTypeCalendar* pCalendarType = dynamic_cast<const CSchemaTypeCalendar*>(&rObject);
	if( pCalendarType == NULL )
		ThrowIncompatibleTypesError();

	m_bIsEmpty = rObject.IsEmpty();
//	CSchemaMonthDay& rOther = (CSchemaMonthDay)(*pCalendarType);	
	CSchemaMonthDay& rOther = (CSchemaMonthDay&)(*pCalendarType);	
	m_nMonth = rOther.m_nMonth;
	m_nDay = rOther.m_nDay;
	SetTimezoneMode( rOther.GetTimezoneMode() );
	if( rOther.GetTimezoneMode() == TZ_Offset )
		SetOffset( rOther.GetOffset() );
	return *this;
}

void CSchemaMonthDay::Empty()
{
	m_bIsEmpty = true;
	time_t long_time;
	time( &long_time ); 
	struct tm *newtime = localtime( &long_time ); 
	m_nMonth = newtime->tm_mon;
	m_nDay = newtime->tm_mday;
}

long CSchemaMonthDay::ApproximatedNormalizedDays() const
{
	return m_nMonth*31+m_nDay;
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaDay
//
////////////////////////////////////////////////////////////////////////


CSchemaDay::CSchemaDay()
{
	Empty();
}


CSchemaDay::CSchemaDay(int nDay, bool bUTC) 
: CSchemaDateTimeBase(bUTC)
{
	m_bIsEmpty = false;
	m_nDay = nDay;
}


CSchemaDay::CSchemaDay(int nDay, int nOffset) 
: CSchemaDateTimeBase(nOffset)
{
	m_bIsEmpty = false;
	m_nDay = nDay;
}


CSchemaDay::CSchemaDay(const TCHAR* szValue) 
{
	Parse(szValue);
}


CSchemaDay::CSchemaDay(const CSchemaType& rObject) 
{
	*this = rObject;
}


CSchemaDay::operator tstring() const
{
	if( m_bIsEmpty )
		return _T("");
	TCHAR szTmp[32];
	int nPos = _stprintf(szTmp, _T("---%02i"), m_nDay);
	WriteTZ(szTmp + nPos);
	return szTmp;
}


bool CSchemaDay::ToBool() const
{
	return !m_bIsEmpty;
}


CSchemaDay::operator CSchemaDate() const
{
	ThrowIncompatibleTypesError();
}

CSchemaDay::operator CSchemaDateTime() const
{
	ThrowIncompatibleTypesError();
}

CSchemaDay::operator CSchemaDay() const
{
	return *this;
}

CSchemaDay::operator CSchemaDuration() const
{
	ThrowIncompatibleTypesError();
}

CSchemaDay::operator CSchemaMonth() const
{
	ThrowIncompatibleTypesError();
}

CSchemaDay::operator CSchemaMonthDay() const
{
	ThrowIncompatibleTypesError();
}

CSchemaDay::operator CSchemaTime() const
{
	ThrowIncompatibleTypesError();
}

CSchemaDay::operator CSchemaYear() const
{
	ThrowIncompatibleTypesError();
}

CSchemaDay::operator CSchemaYearMonth() const
{
	ThrowIncompatibleTypesError();
}



int CSchemaDay::GetDay() const
{
	return m_nDay;
}


void CSchemaDay::SetDay(int nDay)
{
	m_nDay = nDay;
}


void CSchemaDay::Parse(const TCHAR* szValue)
{
	const TCHAR* szTmp = szValue;

	Empty();

	ParseChar(&szTmp, _T('-'));
	ParseChar(&szTmp, _T('-'));
	ParseChar(&szTmp, _T('-'));
	m_nDay = ParseInt(&szTmp);
	ParseTZ(szTmp);

	m_bIsEmpty = false;
}


CSchemaType& CSchemaDay::Assign(const CSchemaType& rObject)
{
	Empty();
	const CSchemaTypeCalendar* pCalendarType = dynamic_cast<const CSchemaTypeCalendar*>(&rObject);
	if( pCalendarType == NULL )
		ThrowIncompatibleTypesError();

	m_bIsEmpty = rObject.IsEmpty();
//	CSchemaDay& rOther = (CSchemaDay)(*pCalendarType);	
	CSchemaDay& rOther = (CSchemaDay&)(*pCalendarType);	
	m_nDay = rOther.m_nDay;
	SetTimezoneMode( rOther.GetTimezoneMode() );
	if( rOther.GetTimezoneMode() == TZ_Offset )
		SetOffset( rOther.GetOffset() );
	return *this;
}

void CSchemaDay::Empty()
{
	m_bIsEmpty = true;
	time_t long_time;
	time( &long_time ); 
	struct tm *newtime = localtime( &long_time ); 
	m_nDay = newtime->tm_mday;
}



////////////////////////////////////////////////////////////////////////
//
//  CSchemaBinaryBase
//
////////////////////////////////////////////////////////////////////////


CSchemaBinaryBase::CSchemaBinaryBase(const CSchemaBinaryBase& rOther)
: m_pData( NULL )
, m_nSize( 0 )
 
{
	Clone(rOther);
}


CSchemaBinaryBase::CSchemaBinaryBase(const unsigned char* pData, int nSize)
: m_pData( NULL )
, m_nSize( 0 )
 
{
	Clone(pData, nSize);
}


CSchemaBinaryBase::~CSchemaBinaryBase()
{
	Empty();
}


void CSchemaBinaryBase::SetData(const unsigned char* pData, int nSize)
{
	Empty();
	Clone(pData, nSize);
}


void CSchemaBinaryBase::Empty()
{
	m_bIsEmpty = true;
	if( m_pData )
		delete[] m_pData;
	m_pData = NULL;
	m_nSize = 0;
}


CSchemaType& CSchemaBinaryBase::Assign(const CSchemaType& rObject)
{
	Empty();
	if( rObject.IsEmpty() || ( tstring )rObject == _T("") )
		return *this;

	const CSchemaBinaryBase* pBinType = dynamic_cast<const CSchemaBinaryBase*>(&rObject);
	if( pBinType != NULL )
	{
		SetData(pBinType->GetData(), pBinType->GetSize());
		m_bIsEmpty = pBinType->IsEmpty();
		return *this;
	}

	ThrowIncompatibleTypesError();
	return *this;
}


void CSchemaBinaryBase::Clone(const CSchemaBinaryBase& rOther)
{
	m_nSize = rOther.m_nSize;
	if (m_nSize == 0)
	{
		m_pData = NULL;
		m_bIsEmpty = true;
		return;
	}
	m_bIsEmpty = false;
	m_pData = new unsigned char[m_nSize];
	memcpy(m_pData, rOther.m_pData, m_nSize);
}


void CSchemaBinaryBase::Clone(const unsigned char* pData, int nSize)
{
	m_nSize = nSize;
	if (m_nSize == 0)
	{
		m_pData = NULL;
		m_bIsEmpty = true;
		return;
	}
	m_bIsEmpty = false;
	m_pData = new unsigned char[m_nSize];
	memcpy(m_pData, pData, m_nSize);
}



////////////////////////////////////////////////////////////////////////
//
//  CSchemaHexBinary
//
////////////////////////////////////////////////////////////////////////


const TCHAR CSchemaHexBinary::sm_EncodeArray[] =
	_T("0123456789ABCDEF");


const char CSchemaHexBinary::sm_DecodeArray[] =
{

	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	 0,	 1,	 2,	 3,	 4,	 5,	 6,	 7,	 8,	 9,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	10,	11,	12,	13,	14,	15,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	10,	11,	12,	13,	14,	15,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1
};


CSchemaHexBinary::CSchemaHexBinary(const TCHAR* szValue)
{
	Parse(szValue);
}


CSchemaHexBinary::CSchemaHexBinary(const CSchemaType& rObject)
{
	*this = rObject;
}


CSchemaHexBinary::operator tstring() const
{
	if (m_bIsEmpty  ||  m_pData == NULL)
	{
		return _T("");
	}

	tstring s;
	s.reserve(m_nSize * 2);
	const unsigned char* pReader = m_pData;
	for (int i = 0; i < m_nSize; i++)
	{
		s += sm_EncodeArray[*pReader >> 4];
		s += sm_EncodeArray[*pReader & 0xF];
		pReader++;
	}
	return s;
}


void CSchemaHexBinary::Parse(const TCHAR* szValue)
{
	Empty();

	m_nSize = _tcslen(szValue) / 2;
	if (m_nSize == 0)
	{
		m_pData = NULL;
		return;
	}
	m_pData = new unsigned char[m_nSize];

	unsigned char* szDataWriter = m_pData;
	while (*szValue && *(szValue + 1))
	{
//		char nDigit1 = sm_DecodeArray[*szValue++];
//		char nDigit2 = sm_DecodeArray[*szValue++];
		char nDigit1 = sm_DecodeArray[(unsigned)(*szValue++)];
		char nDigit2 = sm_DecodeArray[(unsigned)(*szValue++)];
		if (nDigit1 == -1 ||nDigit2 == -1)
			ThrowFormatError();
		*szDataWriter++ = nDigit1 * 16 + nDigit2;
	}

	m_bIsEmpty = false;
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaBase64Binary
//
////////////////////////////////////////////////////////////////////////


const TCHAR CSchemaBase64Binary::sm_EncodeArray[] =
	_T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");


const char CSchemaBase64Binary::sm_DecodeArray[] =
{

	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	62,	-1,	-1,	-1,	63,
	52,	53,	54,	55,	56,	57,	58,	59,	60,	61,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	 0,	 1,	 2,	 3,	 4,	 5,	 6,	 7,	 8,	 9,	10,	11,	12,	13,	14,
	15,	16,	17,	18,	19,	20,	21,	22,	23,	24,	25,	-1,	-1,	-1,	-1,	-1,
	-1,	26,	27,	28,	29,	30,	31,	32,	33,	34,	35,	36,	37,	38,	39,	40,
	41,	42,	43,	44,	45,	46,	47,	48,	49,	50,	51,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1
};


CSchemaBase64Binary::CSchemaBase64Binary(const TCHAR* szValue)
{
	Decode(szValue, m_pData, m_nSize);
	m_bIsEmpty = false;
}


CSchemaBase64Binary::CSchemaBase64Binary(const CSchemaType& rObject)
{
	*this = rObject;
}

CSchemaBase64Binary::operator tstring() const
{
	if (m_bIsEmpty  ||  m_pData == NULL)
	{
		return _T("");
	}

	tstring sResult;
	TCHAR* szDst;
	int nDstSize;

	Encode(m_pData, m_nSize, szDst, nDstSize);
	sResult = szDst;
	delete[] szDst;
	return sResult;
}


void CSchemaBase64Binary::Parse(const TCHAR* szValue)
{
	m_bIsEmpty = false;
	Decode(szValue, m_pData, m_nSize);
}


void CSchemaBase64Binary::Encode(unsigned char* pSrc, int nSrcSize, TCHAR*& rszDst, int& rnDstSize, int nMaxLineLength) const
{
	int				nTmpSize, nAllocSize, nLineLength, i;
	TCHAR*			szDstWriter;
	unsigned long	bBuf;

	if (nSrcSize == 0)
	{
		rszDst = NULL;
		rnDstSize = 0;
		return;
	}

	nTmpSize	= nSrcSize * 4 / 3;
	nAllocSize	= nTmpSize + 8;
	if (nMaxLineLength > 0)
		nAllocSize += nTmpSize * 2 / nMaxLineLength;
	
	rszDst		= new TCHAR[nAllocSize];
	szDstWriter	= rszDst;

	nTmpSize	= nSrcSize / 3 * 3;
	rnDstSize	= 0;
	nLineLength	= 0;

	if (nMaxLineLength > 0)
	{
		for (i = 0; i < nTmpSize; i += 3)
		{
			bBuf = *(pSrc + i) << 16 | *(pSrc + i + 1) << 8 | *(pSrc + i + 2);
			*szDstWriter++ = sm_EncodeArray[(bBuf >> 18) & 0x3F];
			*szDstWriter++ = sm_EncodeArray[(bBuf >> 12) & 0x3F];
			*szDstWriter++ = sm_EncodeArray[(bBuf >>  6) & 0x3F];
			*szDstWriter++ = sm_EncodeArray[ bBuf        & 0x3F];
			rnDstSize += 4;

			nLineLength += 4;
			if (nMaxLineLength > 0 && nLineLength >= nMaxLineLength)
			{
				*szDstWriter++ = _T('\r');
				*szDstWriter++ = _T('\n');
				rnDstSize += 2;
				nLineLength = 0;
			}
		}
	}
	else
	{
		for (i = 0; i < nTmpSize; i += 3)
		{
			bBuf = *(pSrc + i) << 16 | *(pSrc + i + 1) << 8 | *(pSrc + i + 2);
			*szDstWriter++ = sm_EncodeArray[(bBuf >> 18) & 0x3F];
			*szDstWriter++ = sm_EncodeArray[(bBuf >> 12) & 0x3F];
			*szDstWriter++ = sm_EncodeArray[(bBuf >>  6) & 0x3F];
			*szDstWriter++ = sm_EncodeArray[ bBuf        & 0x3F];
			rnDstSize += 4;
		}
	}

	int nRest = nSrcSize - nTmpSize;
	if (nRest == 2)
	{
		bBuf = *(pSrc + i) << 8 | *(pSrc + i + 1);
		*szDstWriter++ = sm_EncodeArray[(bBuf >> 10) & 0x3F];
		*szDstWriter++ = sm_EncodeArray[(bBuf >>  4) & 0x3F];
		*szDstWriter++ = sm_EncodeArray[(bBuf <<  2) & 0x3F];
		*szDstWriter++ = _T('=');
		rnDstSize += 4;
	}
	else if (nRest == 1)
	{
		bBuf = *(pSrc + i);
		*szDstWriter++ = sm_EncodeArray[(bBuf >>  2) & 0x3F];
		*szDstWriter++ = sm_EncodeArray[(bBuf <<  4) & 0x3F];
		*szDstWriter++ = _T('=');
		*szDstWriter++ = _T('=');
		rnDstSize += 4;
	}

	*szDstWriter = 0;
}


void CSchemaBase64Binary::Decode(const TCHAR* szSrc, unsigned char*& rpDst, int& rnDstSize)
{
	int				nSrcSize;
	const TCHAR*	szSrcReader;
	unsigned char*	pDstWriter;
	unsigned long	nBuf;
	int				nCount;

	szSrcReader	= szSrc;
//	while (*szSrcReader && sm_DecodeArray[*szSrcReader] == -1)
	while (*szSrcReader && sm_DecodeArray[(unsigned)(*szSrcReader)] == -1)
	{
		szSrcReader++;
	}
	nSrcSize = _tcslen(szSrcReader);
	if (nSrcSize == 0)
	{
		rpDst = NULL;
		rnDstSize = 0;
		return;
	}

	rpDst		= new unsigned char[nSrcSize];
	pDstWriter	= rpDst;
	rnDstSize	= 0;
	nBuf		= 0;
	nCount		= 0;

	while (*szSrcReader)
	{
//		while (sm_DecodeArray[*szSrcReader] == -1)
		while (sm_DecodeArray[(unsigned)(*szSrcReader)] == -1)
		{
			if (!*++szSrcReader)
				goto finish;
		}

//		nBuf |= sm_DecodeArray[*szSrcReader++];
		nBuf |= sm_DecodeArray[(unsigned)(*szSrcReader++)];

		if (++nCount == 4)
		{
			*pDstWriter++ = (unsigned char)(nBuf >> 16);
			*pDstWriter++ = (unsigned char)(nBuf >>  8);
			*pDstWriter++ = (unsigned char) nBuf;
			rnDstSize += 3;
			nBuf = 0;
			nCount = 0;
		}
		else
		{
			nBuf <<= 6;
		}
	}

finish:
	if (nCount == 2)
	{
		*pDstWriter++ = (unsigned char)(nBuf >> 10);
		rnDstSize++;
	}
	else if (nCount == 3)
	{
		*pDstWriter++ = (unsigned char)(nBuf >> 16) & 0xFF;
		*pDstWriter++ = (unsigned char)(nBuf >>  8) & 0xFF;
		rnDstSize += 2;
	}
}


////////////////////////////////////////////////////////////////////////
//
//  Operators
//
////////////////////////////////////////////////////////////////////////


// equality / not-equal
bool CSchemaType::CompareEqual(const CSchemaType& rObj1, const CSchemaType& rObj2 )
{
	if( rObj1.IsEmpty() != rObj2.IsEmpty() )
		return false;

	const CSchemaType* pObj1 = &rObj1;
	const CSchemaType* pObj2 = &rObj2;

	// check numeric types
//	try
//	{
		const CSchemaTypeNumber* pNum1 = dynamic_cast<const CSchemaTypeNumber*>(pObj1);
		const CSchemaTypeNumber* pNum2 = dynamic_cast<const CSchemaTypeNumber*>(pObj2);
		if( pNum1 &&  pNum2 && 
			pNum1->NumericType() != CSchemaType::k_unknown  &&
			pNum2->NumericType() != CSchemaType::k_unknown )
		{	// both derived from CSchemaTypeNumber
			CSchemaType::ETypes eType1 = pNum1->NumericType();
			CSchemaType::ETypes eType2 = pNum2->NumericType();
			if( eType1 == CSchemaType::k_float  ||  
				eType1 == CSchemaType::k_double  ||  
				eType1 == CSchemaType::k_decimal ||
				eType2 == CSchemaType::k_float  ||  
				eType2 == CSchemaType::k_double  ||  
				eType2 == CSchemaType::k_decimal )
				return pNum1->ToDouble() == pNum2->ToDouble();
			if( pNum1->NumericType() == CSchemaType::k_unsigned_long  ||
				pNum2->NumericType() == CSchemaType::k_unsigned_long )
				return (unsigned LLONG)pNum1->ToInt64() == (unsigned LLONG)pNum2->ToInt64();
			return pNum1->ToInt64() == pNum2->ToInt64();
		}
//	}
//	catch(exception) {}

	// check calendar-types
//	try
//	{
		const CSchemaTypeCalendar* pCal1 = dynamic_cast<const CSchemaTypeCalendar*>(pObj1);
		const CSchemaTypeCalendar* pCal2 = dynamic_cast<const CSchemaTypeCalendar*>(pObj2);
		if( pCal1  &&  pCal2  &&
			pCal1->CalendarType() != CSchemaType::k_unknown  &&
			pCal2->CalendarType() != CSchemaType::k_unknown  )
		{	// both derived from CSchemaCalendar
			switch( pCal1->CalendarType() )
			{
		case CSchemaType::k_Duration:
			{
				CSchemaDuration& dur1 = (CSchemaDuration&)*pCal1;
				CSchemaDuration& dur2 = (CSchemaDuration&)*pCal2;
				return dur1.ApproximatedNormalizedSeconds() == dur2.ApproximatedNormalizedSeconds();
			}
		case CSchemaType::k_Date:
			{
				CSchemaDate& t1 = (CSchemaDate&)*pCal1;
				CSchemaDate& t2 = (CSchemaDate&)*pCal2;
				if (t1.HasTimezone() == t2.HasTimezone())
					return t1.ApproximatedNormalizedDays() == t2.ApproximatedNormalizedDays();
				else
					return false;
			}
		case CSchemaType::k_Time:
			{
				CSchemaTime& t1 = (CSchemaTime&)*pCal1;
				CSchemaTime& t2 = (CSchemaTime&)*pCal2;
				if (t1.HasTimezone() == t2.HasTimezone())
					return t1.NormalizedSeconds() == t2.NormalizedSeconds();
				else
					return false;
			}
		case CSchemaType::k_DateTime:
			{
				CSchemaDateTime& t1 = (CSchemaDateTime&)*pCal1;
				CSchemaDateTime& t2 = (CSchemaDateTime&)*pCal2;
				if (t1.HasTimezone() == t2.HasTimezone())
					return t1.ApproximatedNormalizedSeconds() == t2.ApproximatedNormalizedSeconds();
				else
					return false;
			}
		case CSchemaType::k_Year:
			{
				CSchemaYear& year1 = (CSchemaYear&)*pCal1;
				CSchemaYear& year2 = (CSchemaYear&)*pCal2;
				if( year1.HasTimezone() == year2.HasTimezone() )
					return year1.m_nYear == year2.m_nYear;
				else
					return false;
			}
		case CSchemaType::k_YearMonth:
			{
				CSchemaYearMonth& ym1 = (CSchemaYearMonth&)*pCal1;
				CSchemaYearMonth& ym2 = (CSchemaYearMonth&)*pCal2;
				if( ym1.HasTimezone() == ym2.HasTimezone() )
					return ym1.NormalizedMonths() == ym2.NormalizedMonths();
				else
					return false;
				}
		case CSchemaType::k_Month:
			{
				CSchemaMonth& mon1 = (CSchemaMonth&)*pCal1;
				CSchemaMonth& mon2 = (CSchemaMonth&)*pCal2;
				if( mon1.HasTimezone() == mon2.HasTimezone() )
					return mon1.m_nMonth == mon2.m_nMonth;
				else
					return false;
			}
		case CSchemaType::k_MonthDay:
			{
				CSchemaMonthDay& md1 = (CSchemaMonthDay&)*pCal1;
				CSchemaMonthDay& md2 = (CSchemaMonthDay&)*pCal2;
				if( md1.HasTimezone() == md2.HasTimezone() )
					return md1.ApproximatedNormalizedDays() == md2.ApproximatedNormalizedDays();
				else
					return false;
			}
		case CSchemaType::k_Day:
			{
				CSchemaDay& day1 = (CSchemaDay&)*pCal1;
				CSchemaDay& day2 = (CSchemaDay&)*pCal2;
				if( day1.HasTimezone() == day2.HasTimezone() )
					return day1.m_nDay == day2.m_nDay;
				else
					return false;
			}
		// --- added ---
		default: break ;
		// --- added ---
			}

		}
//	}
//	catch(exception) {}

	// check binary-types
//	try
//	{
		const CSchemaBinaryBase* pBin1 = dynamic_cast<const CSchemaBinaryBase*>(pObj1);
		const CSchemaBinaryBase* pBin2 = dynamic_cast<const CSchemaBinaryBase*>(pObj2);
		if( pBin1  &&  pBin2 )
		{	// binary types
			if( pBin1->m_nSize == pBin2->m_nSize )
				return memcmp(pBin1->m_pData, pBin2->m_pData, pBin1->m_nSize ) == 0;
			return false;
		}
//	}
//	catch(exception) {}

	return (tstring)rObj1 == (tstring)rObj2;
}


// less
bool CSchemaType::CompareLess(const CSchemaType& rObj1, const CSchemaType& rObj2 )
{
	if( rObj1.IsEmpty() && rObj2.IsEmpty() )
		return false;
	if( rObj1.IsEmpty() )
		return true;
	if( rObj2.IsEmpty() )
		return false;

	const CSchemaType* pObj1 = &rObj1;
	const CSchemaType* pObj2 = &rObj2;

	// check numeric types
//	try
//	{
		const CSchemaTypeNumber* pNum1 = dynamic_cast<const CSchemaTypeNumber*>(pObj1);
		const CSchemaTypeNumber* pNum2 = dynamic_cast<const CSchemaTypeNumber*>(pObj2);
		if( pNum1 &&  pNum2 && 
			pNum1->NumericType() != CSchemaType::k_unknown  &&
			pNum2->NumericType() != CSchemaType::k_unknown )
		{	// both derived from CSchemaTypeNumber
			CSchemaType::ETypes eType1 = pNum1->NumericType();
			CSchemaType::ETypes eType2 = pNum2->NumericType();
			if( eType1 == CSchemaType::k_float  ||  
				eType1 == CSchemaType::k_double  ||  
				eType1 == CSchemaType::k_decimal ||
				eType2 == CSchemaType::k_float  ||  
				eType2 == CSchemaType::k_double  ||  
				eType2 == CSchemaType::k_decimal )
				return pNum1->ToDouble() < pNum2->ToDouble();
			if( pNum1->NumericType() == CSchemaType::k_unsigned_long  ||
				pNum2->NumericType() == CSchemaType::k_unsigned_long )
				return (unsigned LLONG)pNum1->ToInt64() < (unsigned LLONG)pNum2->ToInt64();
			return pNum1->ToInt64() < pNum2->ToInt64();
		}
//	}
//	catch(exception) {}

	// check calendar-types
//	try
//	{
		const CSchemaTypeCalendar* pCal1 = dynamic_cast<const CSchemaTypeCalendar*>(pObj1);
		const CSchemaTypeCalendar* pCal2 = dynamic_cast<const CSchemaTypeCalendar*>(pObj2);
		if( pCal1  &&  pCal2  &&
			pCal1->CalendarType() != CSchemaType::k_unknown  &&
			pCal2->CalendarType() != CSchemaType::k_unknown  )
		{	// both derived from CSchemaCalendar
			switch( pCal1->CalendarType() )
			{
		case CSchemaType::k_Duration:
			{
				CSchemaDuration& dur1 = (CSchemaDuration&)*pCal1;
				CSchemaDuration& dur2 = (CSchemaDuration&)*pCal2;
				return dur1.ApproximatedNormalizedSeconds() < dur2.ApproximatedNormalizedSeconds();
			}
		case CSchemaType::k_Date:
			{
				CSchemaDate& t1 = (CSchemaDate&)*pCal1;
				CSchemaDate& t2 = (CSchemaDate&)*pCal2;
				if (t1.HasTimezone() == t2.HasTimezone())
					return t1.ApproximatedNormalizedDays() < t2.ApproximatedNormalizedDays();
				else
					return false;
			}
		case CSchemaType::k_Time:
			{
				CSchemaTime& t1 = (CSchemaTime&)*pCal1;
				CSchemaTime& t2 = (CSchemaTime&)*pCal2;
				if (t1.HasTimezone() == t2.HasTimezone())
					return t1.NormalizedSeconds() < t2.NormalizedSeconds();
				else
					return false;
			}
		case CSchemaType::k_DateTime:
			{
				CSchemaDateTime& t1 = (CSchemaDateTime&)*pCal1;
				CSchemaDateTime& t2 = (CSchemaDateTime&)*pCal2;
				if (t1.HasTimezone() == t2.HasTimezone())
					return t1.ApproximatedNormalizedSeconds() < t2.ApproximatedNormalizedSeconds();
				else
					return false;
			}
		case CSchemaType::k_Year:
			{
				CSchemaYear& year1 = (CSchemaYear&)*pCal1;
				CSchemaYear& year2 = (CSchemaYear&)*pCal2;
				if( year1.HasTimezone() == year2.HasTimezone() )
					return year1.m_nYear < year2.m_nYear;
				else
					return false;
			}
		case CSchemaType::k_YearMonth:
			{
				CSchemaYearMonth& ym1 = (CSchemaYearMonth&)*pCal1;
				CSchemaYearMonth& ym2 = (CSchemaYearMonth&)*pCal2;
				if( ym1.HasTimezone() == ym2.HasTimezone() )
					return ym1.NormalizedMonths() < ym2.NormalizedMonths();
				else
					return false;
				}
		case CSchemaType::k_Month:
			{
				CSchemaMonth& mon1 = (CSchemaMonth&)*pCal1;
				CSchemaMonth& mon2 = (CSchemaMonth&)*pCal2;
				if( mon1.HasTimezone() == mon2.HasTimezone() )
					return mon1.m_nMonth < mon2.m_nMonth;
				else
					return false;
			}
		case CSchemaType::k_MonthDay:
			{
				CSchemaMonthDay& md1 = (CSchemaMonthDay&)*pCal1;
				CSchemaMonthDay& md2 = (CSchemaMonthDay&)*pCal2;
				if( md1.HasTimezone() == md2.HasTimezone() )
					return md1.ApproximatedNormalizedDays() < md2.ApproximatedNormalizedDays();
				else
					return false;
			}
		case CSchemaType::k_Day:
			{
				CSchemaDay& day1 = (CSchemaDay&)*pCal1;
				CSchemaDay& day2 = (CSchemaDay&)*pCal2;
				if( day1.HasTimezone() == day2.HasTimezone() )
					return day1.m_nDay < day2.m_nDay;
				else
					return false;
			}
		// --- added ---
		default: break ;
		// --- added ---
			}

		}
//	}
//	catch(exception) {}

	// check binary-types
//	try
//	{
		const CSchemaBinaryBase* pBin1 = dynamic_cast<const CSchemaBinaryBase*>(pObj1);
		const CSchemaBinaryBase* pBin2 = dynamic_cast<const CSchemaBinaryBase*>(pObj2);
		if( pBin1  &&  pBin2 )
		{	// binary types
			if( pBin1->m_nSize == pBin2->m_nSize )
				return memcmp(pBin1->m_pData, pBin2->m_pData, pBin1->m_nSize ) < 0;
			return pBin1->m_nSize < pBin2->m_nSize;
		}
//	}
//	catch(exception) {}

	return (tstring)rObj1 < (tstring)rObj2;
}

template<> 
float CSchemaUnsignedLong::ToFloat() const
{
	return m_bIsEmpty ? (float)0.0	: InRangeDbl<float>((float)InRangeInt<LLONG>(m_Value, _I64_MIN, _I64_MAX), 3.4E-38, 3.4E+38); 
}

template<>
double CSchemaUnsignedLong::ToDouble() const
{
	return m_bIsEmpty ? (double)0.0	: InRangeDbl<double>((double)InRangeInt<LLONG>(m_Value, _I64_MIN, _I64_MAX), 1.7E-308, 1.7E+308); 	
}

template<>
void CSchemaByte::InternalParse(const TCHAR* szValue)
{
	m_Value = _ttoi(szValue);
}

template<>
void CSchemaUnsignedByte::InternalParse(const TCHAR* szValue)
{
	m_Value = _ttoi(szValue);
}

template<>
void CSchemaShort::InternalParse(const TCHAR* szValue)
{
	m_Value = _ttoi(szValue);
}

template<>
void CSchemaUnsignedShort::InternalParse(const TCHAR* szValue)
{
	m_Value = _ttoi(szValue);
}

template<>
void CSchemaInt::InternalParse(const TCHAR* szValue)
{
	m_Value = _ttol(szValue);
}

template<>
void CSchemaUnsignedInt::InternalParse(const TCHAR* szValue)
{
	m_Value = _ttol(szValue);
}

template<>
void CSchemaLong::InternalParse(const TCHAR* szValue)
{
	m_Value = _ttoi64(szValue);
}

template<>
void CSchemaUnsignedLong::InternalParse(const TCHAR* szValue)
{
	m_Value = _ttoi64(szValue);
}

template<>
void CSchemaFloat::InternalParse(const TCHAR* szValue)
{
	TCHAR* endptr;
	m_Value = (float)_tcstod(szValue, &endptr);
}

template<>
void CSchemaDouble::InternalParse(const TCHAR* szValue)
{
	TCHAR* endptr;
	m_Value = _tcstod(szValue, &endptr);
}

template<>
void CSchemaDecimal::InternalParse(const TCHAR* szValue)
{
	TCHAR* endptr;
	m_Value = _tcstod(szValue, &endptr);
}
} // namespace mcml
