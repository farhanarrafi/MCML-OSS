////////////////////////////////////////////////////////////////////////
//
// Doc.cpp
//
// This file was generated by XMLSPY 2004 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSPY Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////

#include "SchemaTypes.h"
#include "Node.h"
#include "Doc.h"
#include <iostream>
#include <fstream>

namespace mcml {

xmlDocPtr	CDoc::sm_Document			= NULL;
xmlNodePtr	CDoc::sm_Fragment			= NULL;
int			CDoc::sm_nReferenceCounter	= 0;


/**
 * Gets document structure (generates one if none)
 * @return
 */
xmlDocPtr CDoc::GetDocument()
{
	if (sm_Document == NULL)
		sm_Document = xmlNewDoc(X(XML_DEFAULT_VERSION));

	return sm_Document;
}

/**
 *  Generates fragment node, and adds child nodes
 * (If a fragment node already exists, use that)
 * @param pDOMNode
 * @return
 */
xmlNodePtr CDoc::CreateFragment(xmlNodePtr pDOMNode)
{
	if (sm_Fragment == NULL)
	{
		xmlDocPtr pDoc = GetDocument();
		sm_Fragment = xmlNewDocFragment(pDoc);
		if (sm_Fragment == NULL)
			throw CXMLException(1, _T("Could not create fragment"));
		xmlAddChild((xmlNodePtr)pDoc, sm_Fragment);
	}

	if(pDOMNode == NULL)
		pDOMNode = xmlNewNode(NULL, X("tmp"));

	xmlAddChild(sm_Fragment, pDOMNode);
	return pDOMNode;
}

/**
 *  Releases fragment child nodes
 * @param pDOMNode
 */
void CDoc::ReleaseFragment(xmlNodePtr pDOMNode)
{
	if (pDOMNode != NULL && pDOMNode->parent != NULL && pDOMNode->parent->type == XML_DOCUMENT_FRAG_NODE)
	{
		xmlUnlinkNode(pDOMNode);
		xmlFreeNode(pDOMNode);
	}
}

/**
 * Increments reference counter
 */
void CDoc::AddReferenceCount()
{
	sm_nReferenceCounter++;
}

/**
 * Decrements reference counter, releases documents when it becomes 0
 */
void CDoc::DeleteReferenceCount()
{
	if(--sm_nReferenceCounter == 0) {
		xmlFreeDoc(sm_Document);
		sm_Document = NULL;
		sm_Fragment = NULL;
		xmlCleanupParser();
	}
}

/**
 * Default constructor
 */
CDoc::CDoc() : m_sEncoding("utf-8"), m_eSchemaType(None)
{
	AddReferenceCount();
    /*
    m_sRootElementNamespaceURI = tstring(_T(""));
	m_sRootElementName = tstring(_T("MCML"));
    m_eSchemaType = Schema;
	m_sSchemaLocation = tstring(_T("MCML.xsd"));
     */
}

/**
 * Destructor
 */
CDoc::~CDoc()
{
	DeleteReferenceCount();
}


/**
 * Analyzes XML files and converts to xmlNode structures
 * @param sURI
 * @return
 */
xmlNodePtr CDoc::Load(const tstring& sURI)
{
	xmlDocPtr pDoc = xmlParseFile(sURI.c_str());
	if (pDoc == NULL || pDoc->children == NULL)
		CXMLException(1, tstring(_T("Could not load ")) + sURI);

	xmlNodePtr pNode = xmlDocGetRootElement(pDoc);
	xmlUnlinkNode(pNode);
	xmlFreeDoc(pDoc);

	return CreateFragment(pNode);
}

/**
 * Analyzes XML data character string and converts to xmlNode structures
 * @param sXmlData
 * @return
 */
xmlNodePtr CDoc::Parse(const tstring& sXmlData)
{
	xmlDocPtr pDoc = xmlParseMemory(sXmlData.c_str(), sXmlData.size());
	if (pDoc == NULL || pDoc->children == NULL)
		CXMLException(1, tstring(_T("Could not parse string:\n")) + sXmlData);

	xmlNodePtr pNode = xmlDocGetRootElement(pDoc);
	xmlUnlinkNode(pNode);
	xmlFreeDoc(pDoc);

	return CreateFragment(pNode);
}


/**
 * Outputs XML files with xmlNode structures assigned using parameters as root elements
 * @param sURI
 * @param rNode
 * @return
 */
void CDoc::Save(const tstring& sURI, CNode& rNode)
{
	tstring sBuffer = Generate(rNode);
	std::ofstream ofs(sURI.c_str());
	ofs << sBuffer;
	ofs.close();
}

/**
 * Taking xmlNode structures assigned using parameters, generates XML data character strings
 * @param rNode
 * @return
 */
tstring CDoc::Generate(CNode& rNode)
{
    printf("\ntstring CDoc::Generate(CNode& rNode)\n");
	if (rNode.m_pDOMNode->parent == NULL || rNode.m_pDOMNode->parent->type == XML_DOCUMENT_FRAG_NODE)
	{
        printf("\nfinilizingRootElement....\n");
		FinalizeRootElement(rNode);
	}

	xmlDocPtr pDoc = xmlCopyDoc(sm_Document, 0);
	if(sm_Document->intSubset) {
		xmlAddChild((xmlNodePtr)pDoc, (xmlNodePtr)xmlCopyDtd(sm_Document->intSubset));
		pDoc->intSubset = (xmlDtdPtr)pDoc->children;
	}
	xmlAddChild((xmlNodePtr)pDoc, xmlCopyNode(rNode.m_pDOMNode, 1));

	xmlChar* szBuffer = NULL;
	int nLen = 0;
	xmlDocDumpFormatMemoryEnc(pDoc, &szBuffer, &nLen, m_sEncoding.c_str(), 1);
	if(szBuffer == NULL) {
        printf("\nAbout to thrown and exception....\n");
        CXMLException(1, tstring(_T("Could not generate ")) + XC2TS(rNode.m_pDOMNode->name));
    }
    
	xmlFreeDoc(pDoc);
    
	tstring sBuffer = XC2TS(szBuffer);
    printf("\n\nResult:");
    //printf(&sBuffer[0]);
    printf("\n\n\n\n");
	xmlFree(szBuffer);

	return sBuffer;
}

// Inherits XMLSpy generation source function.
void CDoc::SetEncoding(const tstring& sEncoding)
{
	m_sEncoding = sEncoding;
}

// Inherits XMLSpy generation source function.
void CDoc::SetRootElementName(const tstring& sRootElementNamespaceURI, const tstring& sRootElementName)
{
	m_sRootElementNamespaceURI = sRootElementNamespaceURI;
	m_sRootElementName = sRootElementName;
}

// Inherits XMLSpy generation source function.
void CDoc::SetSchemaLocation(const tstring& sSchemaLocation)
{
	m_eSchemaType = Schema;
	m_sSchemaLocation = sSchemaLocation;
}

// Inherits XMLSpy generation source function.
void CDoc::SetDTDLocation(const tstring& sDTDLocation)
{
	m_eSchemaType = DTD;
	m_sSchemaLocation = sDTDLocation;
}

// Inherits XMLSpy generation source function.
void CDoc::RemoveSchemaLocation()
{
	m_eSchemaType = None;
	m_sSchemaLocation = _T("");
}

/**
 * Finalizes root element.
 * @param rNode
 */
void CDoc::FinalizeRootElement(CNode& rNode)
{
	if (m_sRootElementName.empty())
		throw CXMLException(1, _T("Call SetRootElementName first"));

	if( m_eSchemaType == DTD )
		xmlCreateIntSubset(sm_Document, X(m_sRootElementName), X(""), X(m_sSchemaLocation));

	xmlNodePtr pRootElement = rNode.m_pDOMNode;
	if(pRootElement->name)
		xmlFree((void*)pRootElement->name);
	pRootElement->name = xmlStrdup(X(m_sRootElementName));

	if(m_sRootElementNamespaceURI.size() > 0)
		xmlNewNs(pRootElement, X(m_sRootElementNamespaceURI), NULL);
	
	if( m_eSchemaType == Schema )
	{
		xmlSetProp(pRootElement, X("xmlns:xsi"), X("http://www.w3.org/2001/XMLSchema-instance"));

		if (m_sRootElementNamespaceURI.empty())
		{
			if (!m_sSchemaLocation.empty())
				xmlSetProp(pRootElement, X("xsi:noNamespaceSchemaLocation"), X(m_sSchemaLocation));
		}
		else
		{
			if (!m_sSchemaLocation.empty())
				xmlSetProp(pRootElement, X("xsi:schemaLocation"), X(m_sRootElementNamespaceURI + _T(" ") + m_sSchemaLocation));
		}
	}
}

} // namespace mcml
