////////////////////////////////////////////////////////////////////////
//
// Node.cpp
//
// This file was generated by XMLSPY 2004 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSPY Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////

#include "SchemaTypes.h"
#include "Node.h"
#include "Doc.h"

namespace mcml {

/**
 * Default constructor
 */
CNode::CNode()
{
	CDoc::AddReferenceCount();
	m_pDOMNode = CDoc::CreateFragment();
}

/**
 * Constructor (Initializes using xmlNode structure)
 * @param pThisNode
 */
CNode::CNode(xmlNodePtr pThisNode)
{
	CDoc::AddReferenceCount();
	m_pDOMNode = pThisNode;
}


/**
 * Constructor (Initializes using document root element)
 * @param pThisNode
 */
CNode::CNode(xmlDocPtr pDOMDocument)
{
	CDoc::AddReferenceCount();
	m_pDOMNode = xmlDocGetRootElement(pDOMDocument);
}

/**
 * Destructor
 */
CNode::~CNode()
{
	CDoc::ReleaseFragment(m_pDOMNode);
	CDoc::DeleteReferenceCount();
}


// Inherits XMLSpy generation source function.
CNode&	CNode::Assign(const CNode& rOther)
{
	tstring innerText = ((CNode&)rOther).InternalGetElementValue();
	InternalSetElementValue( innerText );
	return *this;
}


// Inherits XMLSpy generation source function.
tstring CNode::GetNodeName()
{
	return (char*)m_pDOMNode->name;
}


// Inherits XMLSpy generation source function.
tstring CNode::GetNodeValue()
{
	if (m_pDOMNode->content)
		return (char*)m_pDOMNode->content;
	else
		return _T("");
}


// Inherits XMLSpy generation source function.
xmlNodePtr CNode::GetDOMNode()
{
	return m_pDOMNode;
}


// Inherits XMLSpy generation source function.
tstring CNode::InternalGetNodeValue(ENodeType eNodeType, xmlNodePtr pNode)
{
	if (pNode == NULL)
		return _T("");

	xmlChar* szContent = NULL;
	if (eNodeType == Element) {
		if(pNode->children && pNode->children->type == XML_TEXT_NODE)
			szContent = xmlNodeGetContent(pNode->children);
	} else {
		szContent = xmlNodeGetContent(pNode);
	}

	tstring sContent;
	if(szContent) {
		sContent = XC2TS(szContent);
		xmlFree(szContent);
	}
	return sContent;
}


// Inherits XMLSpy generation source function.
tstring CNode::InternalGetElementValue()
{
	return InternalGetNodeValue(Element, m_pDOMNode);
}


// Inherits XMLSpy generation source function.
void CNode::InternalSetElementValue(const tstring& sValue)
{
	xmlNodePtr pTextNode = xmlNewDocText(m_pDOMNode->doc, X(sValue));
	xmlNodePtr pChild = m_pDOMNode->children;
	if(pChild) {
		if(pChild->type == XML_TEXT_NODE) {
			xmlReplaceNode(pChild, pTextNode);
			xmlFreeNode(pChild);
		} else {
			xmlAddPrevSibling(pChild, pTextNode);
		}
	} else {
		xmlAddChild(m_pDOMNode, pTextNode);
	}
}


// Inherits XMLSpy generation source function.
bool CNode::InternalNamesMatch(xmlNodePtr pNode, const tstring& sNamespaceURI, const tstring& sName)
{
	const xmlChar* sNodeURI = X("");
	const xmlChar* sNodeName = X("");
	if(pNode->ns && pNode->ns->href)
		sNodeURI = pNode->ns->href;
	if(pNode->name)
		sNodeName = pNode->name;
	return sNamespaceURI.compare(XC2TS(sNodeURI)) == 0 && sName.compare(XC2TS(sNodeName)) == 0;
}


// Inherits XMLSpy generation source function.
int CNode::ChildCountInternal(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName)
{
	xmlChar* szNamespaceURI = NULL;
	if(sNamespaceURI.size() > 0)
		szNamespaceURI = X(sNamespaceURI);

	if (eNodeType == Element)
	{
		int nCount = 0;

		for (xmlNodePtr pNode = m_pDOMNode->children; pNode != NULL; pNode = pNode->next)
			if (pNode->type == XML_ELEMENT_NODE && InternalNamesMatch(pNode, sNamespaceURI, sName))
				nCount++;

		return nCount;
	}
	else
		return xmlHasNsProp(m_pDOMNode, X(sName), szNamespaceURI) ? 1 : 0;
}


// Inherits XMLSpy generation source function.
bool CNode::InternalHasChild(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName)
{
	xmlChar* szNamespaceURI = NULL;
	if(sNamespaceURI.size() > 0)
		szNamespaceURI = X(sNamespaceURI);

	if (eNodeType == Element)
	{
		for (xmlNodePtr pNode = m_pDOMNode->children; pNode != NULL; pNode = pNode->next)
			if (pNode->type == XML_ELEMENT_NODE && InternalNamesMatch(pNode, sNamespaceURI, sName))
				return true;
		
		return false;
	}
	else
		return xmlHasNsProp(m_pDOMNode, X(sName), szNamespaceURI) ? true : false;
}

// Inherits XMLSpy generation source function.
xmlNodePtr CNode::InternalCreate(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, const tstring& sValue)
{
	if (eNodeType == Element)
	{
		xmlNodePtr pElement = xmlNewNode(NULL, X(sName));
		if(sNamespaceURI.size() > 0)
			xmlNewNs(pElement, X(sNamespaceURI), NULL);

		xmlAddChild(pElement, xmlNewText(X(sValue)));
		return pElement;
	}
	else
	{
		return NULL;
	}
}

// Inherits XMLSpy generation source function.
xmlNodePtr CNode::InternalAppend(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, const tstring& sValue)
{
	xmlNodePtr pNode;
	if (eNodeType == Element)
		pNode = xmlNewTextChild(m_pDOMNode, NULL, X(sName), X(sValue));
	else
		pNode = (xmlNodePtr)xmlNewProp(m_pDOMNode, X(sName), X(sValue));

	if(pNode && sNamespaceURI.size() > 0)
		xmlNewNs(pNode, X(sNamespaceURI), NULL);

	return pNode;
}


// Inherits XMLSpy generation source function.
xmlNodePtr CNode::InternalAppendNode(const tstring& sNamespaceURI, const tstring& sName, CNode& rNode)
{
	xmlNodePtr pCloneNode = xmlCopyNode(rNode.m_pDOMNode, 1);
	xmlNodeSetName(pCloneNode, X(sName));
	return xmlAddChild(m_pDOMNode, pCloneNode);
}


// Inherits XMLSpy generation source function.
xmlNodePtr CNode::InternalGetAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex)
{
	xmlChar* szNamespaceURI = NULL;
	if(sNamespaceURI.size() > 0)
		szNamespaceURI = X(sNamespaceURI);

	if (eNodeType == Element)
	{
		int nCount = 0;

		for (xmlNodePtr pNode = m_pDOMNode->children; pNode != NULL; pNode = pNode->next)
			if (pNode->type == XML_ELEMENT_NODE && InternalNamesMatch(pNode, sNamespaceURI, sName))
				if (nCount++ == nIndex)
					return pNode;

		throw CXMLException(1, tstring(_T("Index out of range: ")) + sName);
	}
	else
	{
		xmlAttrPtr pAttr = xmlHasNsProp(m_pDOMNode, X(sName), szNamespaceURI);
		if (pAttr != NULL && pAttr->type != XML_ATTRIBUTE_DECL)
			return (xmlNodePtr)pAttr;
		else
			throw CXMLException(1, tstring(_T("Index out of range: ")) + sName);
	}
}


// Inherits XMLSpy generation source function.
xmlNodePtr CNode::InternalGet(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName)
{
	return InternalGetAt(eNodeType, sNamespaceURI, sName, 0);
}


// Inherits XMLSpy generation source function.
xmlNodePtr CNode::InternalInsertAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex, const tstring& sValue)
{
	if (eNodeType == Element)
		return xmlAddPrevSibling(
				InternalGetAt(eNodeType, sNamespaceURI, sName, nIndex),
				InternalCreate(eNodeType, sNamespaceURI, sName, sValue)
				);
	else
		return InternalAppend(eNodeType, sNamespaceURI, sName, sValue);
}


// Inherits XMLSpy generation source function.
xmlNodePtr CNode::InternalInsertNodeAt(const tstring& sNamespaceURI, const tstring& sName, int nIndex, CNode& rNode)
{
	rNode.m_pDOMNode = xmlAddPrevSibling(
			InternalGetAt(Element, sNamespaceURI, sName, nIndex),
			xmlCopyNode(rNode.m_pDOMNode, 1)
			);

	return rNode.m_pDOMNode;
}


// Inherits XMLSpy generation source function.
xmlNodePtr CNode::InternalReplaceAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex, const tstring& sValue)
{
	if (eNodeType == Element)
		return xmlReplaceNode(
				InternalGetAt(eNodeType, sNamespaceURI, sName, nIndex),
				InternalCreate(eNodeType, sNamespaceURI, sName, sValue)
				);
	else
		return InternalAppend(eNodeType, sNamespaceURI, sName, sValue);
}


// Inherits XMLSpy generation source function.
xmlNodePtr CNode::InternalReplaceNodeAt(const tstring& sNamespaceURI, const tstring& sName, int nIndex, CNode& rNode)
{
	xmlNodePtr pOldNode = rNode.m_pDOMNode;
	rNode.m_pDOMNode = xmlReplaceNode(
			InternalGetAt(Element, sNamespaceURI, sName, nIndex),
			xmlCopyNode(rNode.m_pDOMNode, 1)
			);
	CDoc::ReleaseFragment(pOldNode);

	return rNode.m_pDOMNode;
}


// Inherits XMLSpy generation source function.
void CNode::InternalRemoveAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex)
{
	xmlNodePtr pNode = InternalGetAt(eNodeType, sNamespaceURI, sName, nIndex);
	if (eNodeType == Element)
	{
		xmlUnlinkNode(pNode);
		xmlFreeNode(pNode);
	}
	else
	{
		xmlRemoveProp((xmlAttrPtr)pNode);
		xmlFreeProp((xmlAttrPtr)pNode);
	}
}
} // namespace mcml
